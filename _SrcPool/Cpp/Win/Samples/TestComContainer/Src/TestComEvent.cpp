/*$Workfile: TestComEvent.cpp$: implementation file
  $Revision: 2$ $Date: 2007-03-05 17:33:19$
  $Author: Darko Kolakovic$

  COM container to test ATL DLL.
  Copyright: CommonSoft Inc.
  2006-01-12 Darko Kolakovic
*/

// Group=Examples

#include "stdafx.h"
#include "KHresult.h" //CHresult class
#include "STL/KOStream.h" //_tcout
#include "KTestLog.h"

#define _USE_MIDL_OUTPUT //Use files generated by MIDL
#ifdef _USE_MIDL_OUTPUT
  //Files generated by MIDL compiler
  #include "TestComAtlNet.h"
  #include "TestComAtlNet_i.c"
#else
  //Incorporate information from a type library (.tlb , .odl) or file (.dll, .ocx, .exe)
  //containing a type library resource
  //Fixme! #import "TestComAtl.dll" no_namespace
#endif

extern bool TsWriteToViewLn(LPCTSTR lszText);
///////////////////////////////////////////////////////////////////////////////
class TestComObjEventHandler//: 
  //public DITestAtl7WebEvents
{
public:

  STDMETHODIMP QueryInterface(REFIID riid,
    void** ppv)
  {
    if(riid == IID_IUnknown ||
      riid == IID_ITestAtl7Web)
    {
     // *ppv = static_cast<DITestAtl7WebEvents*>(this);
      ((IUnknown*)(*ppv))->AddRef();
      return S_OK;
    } else
    {
      return E_NOINTERFACE;
    }
  }
  STDMETHODIMP_(ULONG) AddRef()

  {
    return 2; // This is a global object.
  }
  STDMETHODIMP_(ULONG) Release()
  {
    return 1; // This is a global object.
  }
  /*
  STDMETHODIMP Event1(short x)
  {
  // Handle event 1.
  return S_OK;
  }
  */
  STDMETHODIMP TestAtlEvent(BSTR bstrValue)
  {
    // Handle event 2.
    return S_OK;
  }

};

//-----------------------------------------------------------------------------
/*Testing exceptions based on HRESULT.

  Returns: true if successful, otherwise returns false.

  Note: Microsoft Windows specific (Win32).

  See also: AtlThrow()
*/
bool TestMethod()
{
TsWriteToViewLn(_T("TestMethod()"));
bool bResult = true;

CHresult hResult(S_OK);
try
  {
  ITestAtl7Obj* pcomTest = NULL;
  hResult = CoCreateInstance( CLSID_TestAtl7Obj,//coclass guid  used to create
                              //the object.
                              NULL,
                              CLSCTX_ALL, //.exe COM could run as an out-of-process
                              IID_ITestAtl7Obj,
                              (void**)& pcomTest);
  //Test passing a parameter
  long lResult;
  pcomTest->TestMethod(7, &lResult);
  std::_tcout << _T("2 + 7 = ") << lResult << std::endl;

  pcomTest->Release();
  }
catch(...)
  {
  ::SetLastError(DWORD((HRESULT)hResult));
  std::_tcout << hResult.ErrorMessage() << std::endl;
  bResult = false;
  }

TsWriteToViewLn(LOG_EOT);
return bResult;
}
///////////////////////////////////////////////////////////////////////////////
#include <atlcom.h> //IDispEventImpl
const UINT ID_TESTCOMSINK = 20060830; //arbitrary positive integer as a unique 
                                      //identifier for the source object. 
/*The object of this class, also called a sink, handles (sinks) events 
  generated (fired) by the COM server or the event source.
  The classs implements COM server's outgoing {html:<code>}dispinterface{html:</code>} 
  interface. This interface is declared in the type-library of the server. For 
  every distinct event, the server (connectable object) will call the methods 
  of this interface. The client (subscriber) informs the server about the event
  handler through the {html:<code>}IConnectionPoint{html:</code>} interface.
  Every connection consists of a client-supplied event sink and an identifying 
  cookie.
 */
class CSinkObjNI : public IDispEventImpl<ID_TESTCOMSINK, CSinkObjNI>
{
//Requires AtlGetObjectSourceInterface() to extract information from the type library. Use of AtlGetObjectSourceInterface() requires that the COM object firing the event implement either IProvideClassInfo2 or IPersist*:
public:
  BEGIN_SINK_MAP(CSinkObjNI)
    SINK_ENTRY(ID_TESTCOMSINK, 1 /*DISPID*/, OnTestAtlEvent /*Event Handler*/)
  END_SINK_MAP()
  // event handler for event defined in IDL as
  // HRESULT TestAtlEvent([in] BSTR bstrValue);
  HRESULT __stdcall OnTestAtlEvent(BSTR bstrValue)
  {
    ATLTRACE("CSinkObjNI::OnTestAtlEvent()\n");
    return S_OK;
  }
};
 
class CSinkObj : public IDispEventImpl<ID_TESTCOMSINK, CSinkObj,
  &DIID_DITestAtl7WebEvents, // Source interface GUID.
  &LIBID_TestComAtlNetLib, // typelib ID containing source interface.
  1,                // major version number of LIBID_...
  0>                // minor version number of LIBID_...
{
public:
  BEGIN_SINK_MAP(CSinkObj)
    SINK_ENTRY_EX(ID_TESTCOMSINK, DIID_DITestAtl7WebEvents, 1, OnTestAtlEvent)
  END_SINK_MAP()
  // event handler for event defined in IDL as
  // HRESULT TestAtlEvent([in] BSTR bstrValue);
  HRESULT __stdcall OnTestAtlEvent(BSTR bstrValue)
  {
    ATLTRACE("CSinkObj::OnTestAtlEvent()\n");
    return S_OK;
  }

};

/*
class ATL_NO_VTABLE CSinkObjCO :
  public CComObjectRootEx<CComSingleThreadModel>,
  public CComCoClass<CSinkObjCO, &CLSID_SinkObj>,
  public IDispatchImpl<ISinkObj, &IID_ISinkObj, &LIBID_SINKPROJLib>,
  public IDispEventImpl<ID_TESTCOMSINK, CSinkObjCO>
{
  // event handler for event defined in IDL as
  // HRESULT TestAtlEvent([in] BSTR bstrValue);
  HRESULT __stdcall OnTestAtlEvent(BSTR bstrValue)
  {
    ATLTRACE("CSinkObjCO::OnTestAtlEvent()\n");
    return S_OK;
  }
};
*/
class TestComWebEventHandler2: 
  //public IDispEventImpl<ID_TESTCOMSINK, TestComWebEventHandler>,
public DITestAtl7WebEvents,
public CComObjectRoot 
{
public:

//  BEGIN_COM_MAP(TestComWebEventHandler) 
//    COM_INTERFACE_ENTRY(DITestAtl7WebEvents) 
//  END_COM_MAP() 


STDMETHODIMP TestAtlEvent(BSTR bstrValue)
{
    // Handle event 2.
    return S_OK;
}

};
///////////////////////////////////////////////////////////////////////////////
class TestComWebEventHandler : 
                public IDispEventImpl<1, 
                                      TestComWebEventHandler,
                                      &DIID_DITestAtl7WebEvents,
                                      &LIBID_TestComAtlNetLib, 
                                      1, 
                                      0>,
                                 //     public IDispatchImpl<DITestAtl7WebEvents, &DIID_DITestAtl7WebEvents,
                                  //       &LIBID_TestComAtlNetLib>,
                                      public CComObjectRootEx<CComSingleThreadModel>
//                                       public IDispatchImpl<IFavoritesListbox, &IID_IFavoritesListbox
                                       
//                                       public IDispEventImpl<IDC_BUTTON1, CFavoritesListbox>

{
public:
//The event sink map correlates the callback functions with their DISPIDs 
  BEGIN_SINK_MAP(TestComWebEventHandler)
   // SINK_ENTRY(1, 1 , OnTestAtlEvent)

    SINK_ENTRY_EX (1, DIID_DITestAtl7WebEvents, 1, OnTestAtlEvent)
  END_SINK_MAP()

  void _stdcall OnTestAtlEvent(long NumMessages)
  {
   ATLASSERT(false);
   
  }

}; // End of nested class 




//-----------------------------------------------------------------------------
/*Testing exceptions based on HRESULT.

  Returns: true if successful, otherwise returns false.

  Note: Microsoft Windows specific (Win32).

  See also: AtlThrow()
*/
bool TestComEvents()
{
TsWriteToViewLn(_T("TestComEvents()"));
bool bResult = true;
CHresult hResult(S_OK);

try
  {
  //ITestAtl7Web* pcomTest = NULL;
  CComPtr<ITestAtl7Web> spcomTest;
//  std::_tcout << _T("CoCreateInstance() of TestAtl7Obj failed!") << std::endl;

  hResult = CoCreateInstance( CLSID_TestAtl7Web,//coclass guid  used to create
                              //the object.
                              NULL,
                              CLSCTX_ALL, //.exe COM could run as an out-of-process
                              IID_ITestAtl7Web,
                              (void**)& spcomTest);
  /*Validate existence of Connection Point Container interface. The COM Server 
    can send events to more than one client. All connections are managed 
    through the IConnectionPointContainer interface.
   */
  CComPtr<IConnectionPointContainer> spCPC; 
  hResult = spcomTest->QueryInterface(__uuidof(IConnectionPointContainer), 
                                      (void**) &spCPC); 
  //Get Connection Point of interest
  CComPtr<IConnectionPoint> spCP; 
  hResult = spCPC->FindConnectionPoint( __uuidof(DITestAtl7WebEvents), &spCP); 
  
  //Establish a connection between the connection point and a sink (event handler).
  DWORD dwCookie = 0;
  //TestComWebEventHandler test;
  CComPtr<CComObject<CSinkObj> > spEventSink; 
  hResult = CComObject<CSinkObj>::CreateInstance(&spEventSink); 

  //Establish a connection with the event source 
  hResult = spEventSink->DispEventAdvise(spCP);
  //hResult = spEventSink->Advise(spCP);
  //hResult = spCP->Advise(spEventSink.p, //interface of client's advise sink
  //                         //receiving outgoing calls from the connection point
  //                       &dwCookie); //returned unique identifier of this 
                                     //connection
  //Wait for the event
  
  //Done
  hResult = spCP->Unadvise(dwCookie);
  //Note: CComPtr destructor releases the underlined interface
  }
catch(...)
  {
  ::SetLastError(DWORD((HRESULT)hResult));
  std::_tcout << hResult.ErrorMessage() << std::endl;
  bResult = false;
  }

TsWriteToViewLn(LOG_EOT);
return bResult;
};

//-----------------------------------------------------------------------------
HRESULT ConnectToObject(IUnknown *pObject, 
                        DITestAtl7WebEvents *pEventSink, 
                        DWORD *pdwCookie
                        ) 
{
IConnectionPointContainer *pcpc = 0;
HRESULT hRes;
hRes = pObject->QueryInterface(IID_IConnectionPointContainer,
                                (void**)&pcpc);
if(SUCCEEDED(hRes)) 
  {
  IConnectionPoint *pcp = 0;
  hRes = pcpc->FindConnectionPoint(DIID_DITestAtl7WebEvents, 
                                    &pcp);
  if(SUCCEEDED(hRes)) 
    {
    hRes = pcp->Advise(pEventSink, pdwCookie);
    pcp->Release();
    }
  pcpc->Release();
  }
return hRes;
}

//-----------------------------------------------------------------------------
HRESULT DisconnectFromObject(IUnknown *pObject, 
                             DWORD pdwCookie) 
{
IConnectionPointContainer *pcpc = 0;
HRESULT hRes;
hRes = pObject->QueryInterface(IID_IConnectionPointContainer, (void**)&pcpc);
if(SUCCEEDED(hRes)) 
  {
  IConnectionPoint *pcp = 0;
  hRes = pcpc->FindConnectionPoint(DIID_DITestAtl7WebEvents, &pcp);
  if(SUCCEEDED(hRes)) 
    {
    hRes = pcp->Unadvise(pdwCookie);
    pcp->Release( );
    }
  pcpc->Release( );
  }
return hRes;
}

///////////////////////////////////////////////////////////////////////////////
/******************************************************************************
* $Log: 
*  2    Biblioteka1.1         2007-03-05 17:33:19  Darko Kolakovic Event sink
*  1    Biblioteka1.0         2007-03-02 19:44:52  Darko Kolakovic 
* $
*****************************************************************************/
