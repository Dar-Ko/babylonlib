/*$Workfile: TestComEvent.cpp$: implementation file
  $Revision: 4$ $Date: 2007-03-11 01:21:38$
  $Author: Darko$

  COM container to test ATL DLL.
  Copyright: CommonSoft Inc.
  2006-01-12 Darko Kolakovic
*/

// Group=Examples

#include "stdafx.h"
#include "KHresult.h" //CHresult class
#include "STL/KHexStream.h" //hex class
#include "KTestLog.h"
#include "TestComWebEventHandlerRt.h"

#define _USE_MIDL_OUTPUT //Use files generated by MIDL
#ifdef _USE_MIDL_OUTPUT
  //Files generated by MIDL compiler
  #include "TestComAtlNet.h"
  #include "TestComAtlNet_i.c"
#else
  //Incorporate information from a type library (.tlb , .odl) or file (.dll, .ocx, .exe)
  //containing a type library resource
  //Fixme! #import "TestComAtl.dll" no_namespace
#endif

extern bool TsWriteToViewLn(LPCTSTR lszText);

///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
/*Testing ...

  Returns: true if successful, otherwise returns false.

  Note: Microsoft Windows specific (Win32).

  See also: AtlThrow()
*/
bool TestMethod()
{
TsWriteToViewLn(_T("TestMethod()"));
bool bResult = true;

CHresult hResult(S_OK);
try
  {
  ITestAtl7Obj* pcomTest = NULL;
  hResult = CoCreateInstance( CLSID_TestAtl7Obj,//coclass guid  used to create
                              //the object.
                              NULL,
                              CLSCTX_ALL, //.exe COM could run as an out-of-process
                              IID_ITestAtl7Obj,
                              (void**)& pcomTest);
  //Test passing a parameter
  long lResult;
  pcomTest->TestMethod(7, &lResult);
  std::_tcout << _T("2 + 7 = ") << lResult << std::endl;

  pcomTest->Release();
  }
catch(...)
  {
  ::SetLastError(DWORD((HRESULT)hResult));
  std::_tcout << hResult.ErrorMessage() 
              << _T(" (") << thex((HRESULT)hResult) << _T(')') << std::endl;
  bResult = false;
  }

TsWriteToViewLn(LOG_EOT);
return bResult;
}

//-----------------------------------------------------------------------------
/*Testing exceptions based on HRESULT.

  Returns: true if successful, otherwise returns false.

  Note: Microsoft Windows specific (Win32).

  See also: AtlThrow()
*/
bool TestComEvents()
{
TsWriteToViewLn(_T("TestComEvents()"));
bool bResult = true;
CHresult hResult(S_OK);
TestComWebEventHandlerRt* pEventSink = NULL; 
CComPtr<ITestAtl7Web> spcomTest;

try
  {
  hResult = CoCreateInstance( CLSID_TestAtl7Web,//coclass guid  used to create
                              //the object.
                              NULL,
                              CLSCTX_ALL, //.exe COM could run as an out-of-process
                              IID_ITestAtl7Web,
                              (void**)& spcomTest);
                              
  /*Validate existence of Connection Point Container interface. The COM Server 
    can send events to more than one client. All connections are managed 
    through the IConnectionPointContainer interface.
   */
  CComPtr<IConnectionPointContainer> spCPC; 
  hResult = spcomTest->QueryInterface(__uuidof(IConnectionPointContainer), 
                                      (void**) &spCPC); 
  //Get Connection Point of interest
  CComPtr<IConnectionPoint> spCP; 
  hResult = spCPC->FindConnectionPoint( __uuidof(DITestAtl7WebEvents), &spCP); 


  //Test receiving events (event sink)
  
  //Establish a connection between the connection point and a sink (event handler).
  pEventSink = new TestComWebEventHandlerRt();

  /*Establish a connection with the event source (COM server/publisher object).
    The source will be queried for the Connection Point Container interface. 
    Events fired from the source will be routed to handlers in the sink class 
    by way of the event sink map. 
   */
  hResult = pEventSink->DispEventAdvise(spcomTest);
  //Wait for the event in the message loop
  while(pEventSink->m_nTickCounter <= pEventSink->TESTCOUNTMAX)
    {
      /*In the single-threaded apartment (STA), marshaling process translates 
        the event from the synchronization objects into a WM_USER messages and 
        posts the result to a hidden top-level window associated with the 
        apartment when it was created.
       */
    switch (::MsgWaitForMultipleObjects(1,
                                        &pEventSink->m_clSignal.m_h,
                                        FALSE, 
                                        10000, 
                                        QS_ALLINPUT))
      {
      case WAIT_OBJECT_0: //event of the interest
        break;
      case WAIT_OBJECT_0 + 1: //a windows message
        {
        //Forward windows message
        MSG msg;
        while(::PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
          {
          if (msg.message == WM_QUIT)
            {
            //If it is a quit message, exit.
            pEventSink->m_nTickCounter = pEventSink->TESTCOUNTMAX;
            break;
            }
          ::DispatchMessage(&msg);
          }
        }
        break;
      case WAIT_TIMEOUT: //time-out interval elapsed
        hResult = ERROR_TIMEOUT;
        break;
      case WAIT_FAILED:  //the function failed
        hResult = GetLastError(); //throws exception
        break;
      default:
        break;
      }
    }
  }
catch(...)
  {
  ::SetLastError(DWORD((HRESULT)hResult));
  std::_tcout << hResult.ErrorMessage() << std::endl;
  bResult = false;
  }

  //Disconnect from source if connected
if (pEventSink != NULL)
  {
  if (pEventSink->m_dwEventCookie != 0xFEFEFEFE)
    pEventSink->DispEventUnadvise(spcomTest);
  delete pEventSink;
  }

  //Note: CComPtr destructor releases the underlined interface

TsWriteToViewLn(LOG_EOT);
return bResult;
};

//-----------------------------------------------------------------------------
HRESULT ConnectToObject(IUnknown *pObject, 
                        DITestAtl7WebEvents *pEventSink, 
                        DWORD *pdwCookie
                        ) 
{
IConnectionPointContainer *pcpc = 0;
HRESULT hRes;
hRes = pObject->QueryInterface(IID_IConnectionPointContainer,
                                (void**)&pcpc);
if(SUCCEEDED(hRes)) 
  {
  IConnectionPoint *pcp = 0;
  hRes = pcpc->FindConnectionPoint(DIID_DITestAtl7WebEvents, 
                                    &pcp);
  if(SUCCEEDED(hRes)) 
    {
    hRes = pcp->Advise(pEventSink, pdwCookie);
    pcp->Release();
    }
  pcpc->Release();
  }
return hRes;
}

//-----------------------------------------------------------------------------
HRESULT DisconnectFromObject(IUnknown *pObject, 
                             DWORD pdwCookie) 
{
IConnectionPointContainer *pcpc = 0;
HRESULT hRes;
hRes = pObject->QueryInterface(IID_IConnectionPointContainer, (void**)&pcpc);
if(SUCCEEDED(hRes)) 
  {
  IConnectionPoint *pcp = 0;
  hRes = pcpc->FindConnectionPoint(DIID_DITestAtl7WebEvents, &pcp);
  if(SUCCEEDED(hRes)) 
    {
    hRes = pcp->Unadvise(pdwCookie);
    pcp->Release( );
    }
  pcpc->Release( );
  }
return hRes;
}

///////////////////////////////////////////////////////////////////////////////
/******************************************************************************
* $Log: 
*  4    Biblioteka1.3         2007-03-11 01:21:38  Darko           Event sink and 
*       apartman message loop
*  3    Biblioteka1.2         2007-03-08 20:40:24  Darko Kolakovic Event sink
*  2    Biblioteka1.1         2007-03-05 17:33:19  Darko Kolakovic Event sink
*  1    Biblioteka1.0         2007-03-02 19:44:52  Darko Kolakovic 
* $
*****************************************************************************/
