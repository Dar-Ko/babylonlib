<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en-us">

<!--/* Group=Standards*/ -->

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Language" content="en-us" />
  <meta name="Workfile" content="$Workfile: ZModem.htm$: documentation" />
  <meta name="Revision" content="$Revision: 13$ $Date: 2007-01-10 17:28:41$" />
  <meta name="robots" content="index" />
  <meta name="keywords" content="ZModem, network, protocol" />
  <!-- Dublin Core Metadata Package -->
  <meta name="DC.title" content="XModem / YModem Protocol Reference" />
  <meta name="DC.creator" content="Forsberg, Chuck" />
  <meta name="DC.creator.vCard.EMAIL.internet" content />
  <meta name="DC.Contributor" content="$Author: Darko Kolakovic$" />
  <meta name="DC.Rights" content="&copy; Omen Technology Inc, 1988." />
  <meta name="DC.subject" content="file transfer protocol " />
  <meta name="DC.description.abstract" content="ZModem File transfer protocol">
  <meta name="DC.publisher" content="CommonSoft Inc." />
  <meta name="DC.date" content="1988-10-14" />
  <meta name="DC.type" content="Text.Article" />
  <meta name="DC.format" content="application/html" />
  <meta name="DC.language" content="en_us" />
  <meta name="DC.identifier.ISBN" content="" />
  <meta name="DC.relation.HasVersion" content="" />
  <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" />
  <link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" />
  <title>The ZMODEM Inter Application File Transfer Protocol</title>
  <link rel="stylesheet" type="text/css" href="../Res/KDocument.css" />
  <link rel="stylesheet" type="text/css" href="../Res/Tables.css" />
  <link rel="icon" type="image/ico" href="../Res/KBook.ico" />
  <base target="_self" />

</head>

<body>
  <h1 align="center">The ZMODEM Inter Application File Transfer Protocol</h1>

  <p>Chuck Forsberg<br />
   Omen Technology Inc<br />
   A overview of this document is available as ZMODEM.OV (in ZMDMOV.ARC)<br />
   </p>
   <i>This file may be redistributed without restriction provided the
  text is not altered.<br />
   Please distribute as widely as possible.<br /></i></p>

  <address>
    Omen Technology Incorporated<br />
     The High Reliability Software<br />
     17505-V Northwest Sauvie Island Road<br />
     Portland Oregon 97231<br />
     VOICE: 503-621-3406 :VOICE<br />
     Modem: 503-621-3746 Speed 1200,2400,19200(Telebit PEP)<br />
     Compuserve:70007,2304 GEnie:CAF<br />
     UUCP: ...!tektronix!reed!omen!caf
  </address>

  <p><small><i>Rev 1988-10-14 Typeset 1988-10-14 1</i><br />
   ZMODEM Protocol 2</small></p>

  <h2>Contents</h2>

  <ul>
    <li><a href="#ID1_">1. Intended Audience</a></li>
    <li><a href="#ID2_">2. Why Develop ZMODEM?</a></li>
    <li>
      <a href="#ID3_">3. ZMODEM Protocol Design Criteria</a>

      <ul>
        <li><a href="#ID3_1_">3.1 Ease of Use</a></li>
        <li><a href="#ID3_2_Throughput">3.2 Throughput</a></li>
        <li><a href="#ID3_3_">3.3 Integrity and Robustness</a></li>
        <li><a href="#ID3_4_">3.4 Ease of Implementation</a></li>
      </ul>
    </li>
    <li><a href="#ID4_">4. Evolution Of ZMODEM</a></li>
    <li><a href="#ID5_">5. Rosetta Stone</a></li>
    <li>
      <a href="#ID6_">6. ZMODEM Requirements</a>

      <ul>
        <li><a href="#ID6_1_">6.1 File Contents</a></li>
      </ul>
    </li>
    <li>
      <a href="#ID7_">7. ZMODEM Basics</a>

      <ul>
        <li><a href="#ID7_1_Packetization">7.1 Packetization</a></li>
        <li><a href="#ID7_2_">7.2 Link Escape Encoding</a></li>
        <li><a href="#ID7_3_Header">7.3 Header</a></li>
        <li><a href="#ID7_4_">7.4 Binary Data Subpackets</a></li>
        <li><a href="#ID7_5_">7.5 ASCII Encoded Data Subpacket</a></li>
      </ul>
    </li>
    <li>
      <a href="#ID8_Protocol_Transaction_Overview">8. Protocol Transaction
      Overview</a>

      <ul>
        <li><a href="#ID8_1_">8.1 Session Startup</a></li>
        <li><a href="#ID8_2_">8.2 File Transmission</a></li>
        <li><a href="#ID8_3_">8.3 Session Cleanup</a></li>
        <li><a href="#ID8_4_">8.4 Session Abort Sequence</a></li>
      </ul>
    </li>
    <li>
      <a href="#ID9_">9. Streaming Techniques / Error Recovery</a>

      <ul>
        <li><a href="#ID9_1_">9.1 Full Streaming with Sampling</a></li>
        <li><a href="#ID9_2_">9.2 Full Streaming with Reverse
        Interrupt</a></li>
        <li><a href="#ID9_3_">9.3 Full Streaming with Sliding Window</a></li>
        <li><a href="#ID9_4_">9.4 Full Streaming over Error Free
        Channels</a></li>
        <li><a href="#ID9_5_">9.5 Segmented Streaming</a></li>
      </ul>
    </li>
    <li><a href="#ID10_">10. Attention Sequence</a></li>
    <li>
      <a href="#ID11_">11. Frame Types</a>

      <ul>
        <li><a href="#ID11_1_ZRQINIT">11.1 ZRQINIT</a></li>
        <li><a href="#ID11_2_ZRINIT">11.2 ZRINIT</a></li>
        <li><a href="#ID11_3_ZSINIT">11.3 ZSINIT</a></li>
        <li><a href="#ID11_4_ZACK">11.4 ZACK</a></li>
        <li><a href="#ID11_5_ZFILE">11.5 ZFILE</a></li>
        <li><a href="#ID11_6_ZSKIP">11.6 ZSKIP</a></li>
        <li><a href="#ID11_7_ZNAK">11.7 ZNAK</a></li>
        <li><a href="#ID11_8_ZABORT">11.8 ZABORT</a></li>
        <li><a href="#ID11_9_ZFIN">11.9 ZFIN</a></li>
        <li><a href="#ID11_10_ZRPOS">11.10 ZRPOS</a></li>
        <li><a href="#ID11_11_ZDATA">11.11 ZDATA</a></li>
        <li><a href="#ID11_12_ZEOF">11.12 ZEOF</a></li>
        <li><a href="#ID11_13_ZFERR">11.13 ZFERR</a></li>
        <li><a href="#ID11_14_ZCRC">11.14 ZCRC</a></li>
        <li><a href="#ID11_15_ZCHALLENGE">11.15 ZCHALLENGE</a></li>
        <li><a href="#ID11_16_ZCOMPL">11.16 ZCOMPL</a></li>
        <li><a href="#ID11_17_ZCAN">11.17 ZCAN</a></li>
        <li><a href="#ID11_18_ZFREECNT">11.18 ZFREECNT</a></li>
        <li><a href="#ID11_19_ZCOMMAND">11.19 ZCOMMAND</a></li>
      </ul>
    </li>
    <li>
      <a href="#ID12_">12. Session Transaction Examples</a>

      <ul>
        <li><a href="#ID12_1_">12.1 A simple file transfer</a></li>
        <li><a href="#ID12_2_">12.2 Challenge and Command Download</a></li>
      </ul>
    </li>
    <li><a href="#ID13_">13. ZFILE Frame File Information</a></li>
    <li>
      <a href="#ID14_">14. Performance Results</a>

      <ul>
        <li><a href="#ID14_1_Compatibility">14.1 Compatibility</a></li>
        <li><a href="#ID14_2_Throughput">14.2 Throughput</a></li>
        <li><a href="#ID14_3_">14.3 Error Recovery</a></li>
      </ul>
    </li>
    <li><a href="#ID15_">15. Packet Switched Network Considerations</a></li>
    <li><a href="#ID16_">16. Performance Comparison Tables</a></li>
    <li><a href="#ID17_">17. Future Extensions</a></li>
    <li><a href="#ID18_Revisions">18. Revisions</a></li>
    <li>
      <a href="#ID19_">19. More Information</a>

      <ul>
        <li><a href="#ID19_1_">19.1 TeleGodzilla Bulletin Board</a></li>
        <li><a href="#ID19_2_">19.2 Unix UUCP Access</a></li>
      </ul>
    </li>
    <li>
      <a href="#ID20_">20. ZMODEM Programs</a>

      <ul>
        <li><a href="#ID20_1_">20.1 Adding ZMODEM to DOS Programs</a></li>
      </ul>
    </li>
    <li><a href="#ID21_">21. YMODEM Programs</a></li>
    <li><a href="#ID22_">22. Acknowledgments</a></li>
    <li><a href="#ID23_">23. Related Files</a></li>
    <li>
      List Of Figures

      <ul>
        <li><a href="#Figure1">Figure 1. Order of Bytes in Header</a></li>
        <li><a href="#Figure2">Figure 2. 16 Bit CRC Binary Header</a></li>
        <li><a href="#Figure3">Figure 3. 32 Bit CRC Binary Header</a></li>
        <li><a href="#Figure4">Figure 4. HEX Header</a></li>
        <li><a href="#Figure5">Figure 5. Transmission Time Comparison</a></li>
      </ul>
    </li>
    <li>
      List Of Tables

      <ul>
        <li><a href="#TABLE1">Table 1. Network And Flow Control
        Compatibility</a></li>
        <li><a href="#TABLE2">Table 2. Protocol Overhead Information</a></li>
        <li><a href="#TABLE3">Table 3. Local Timesharing Computer Download
        Performance</a></li>
        <li><a href="#TABLE4">Table 4. File Transfer Speeds</a></li>
        <li><a href="#TABLE5">Table 5. Protocol Checklist</a></li>
      </ul>
    </li>
  </ul>

  <h2><a name="Abstract" id="Abstract">Abstract</a></h2>The ZMODEM file
  transfer protocol provides reliable file and command transfers with complete
  END-TO-END data integrity between application programs. ZMODEM&#39;s 32 bit
  CRC protects against errors that continue to sneak into even the most
  advanced networks.

  <p>Unlike traditional and many recently introduced protocols, ZMODEM
  safeguards all data and supervisory information with effective error
  detection.</p>

  <p>ZMODEM rapidly transfers files, particularly with buffered (error
  correcting) modems, timesharing systems, satellite relays, and wide area
  packet switched networks.</p>

  <p>User Friendliness is an important ZMODEM feature. ZMODEM AutoDownload
  (Automatic file Download initiated without user intervention) greatly
  simplifies file transfers compared to the traditional protocols.</p>

  <p>ZMODEM provides advanced file management features including Crash
  Recovery, flexible control of selective file transfers, and security verified
  command downloading.</p>

  <p>ZMODEM protocol features allow implementation on a wide variety of systems
  operating in a wide variety of environments. A choice of buffering and
  windowing modes allows ZMODEM to operate on systems that cannot support other
  streaming protocols. Finely tuned control character escaping allows operation
  with real world networks without Kermit&#39;s high overhead.</p>

  <p>ZMODEM is the only high performance high reliability public protocol that
  does not require large buffer allocations for normal file transfers.</p>

  <p>Although ZMODEM software is more complex than unreliable XMODEM routines,
  a comphrensive protocol description and actual C source code to production
  programs have allowed dozens of developers to upgrade their applications with
  efficient, reliable ZMODEM file transfers with a minimum of effort.</p>

  <p>ZMODEM was developed for the public domain under a Telenet contract. The
  ZMODEM protocol descriptions and the Unix rz/sz program source code are
  public domain. No licensing, trademark, or copyright restrictions apply to
  the use of the protocol, the Unix rz/sz source code and the ZMODEM name.</p>
  <hr />

  <h2><a name="ID1_" id="ID1_">1. Intended Audience</a></h2>

  <p>This document is intended for telecommunications managers, systems
  programmers, and others who choose and implement asynchronous file transfer
  protocols over dial-up networks and related environments.</p>

  <h2><a name="ID2_" id="ID2_">2. Why Develop ZMODEM?</a></h2>

  <p>Since its development half a decade ago, the Ward Christensen MODEM
  protocol has enabled a wide variety of computer systems to interchange data.
  There is hardly a communications program that doesn&#39;t at least claim to
  support this protocol, now called XMODEM.</p>

  <p>Advances in computing, modems and networking have spread the XMODEM
  protocol far beyond the micro to micro environment for which it was designed.
  These application have exposed some weaknesses:</p>

  <ul>
    <li>The awkward user interface is suitable for computer hobbyists. Multiple
    commands must be keyboarded to transfer each file.</li>
    <li>Since commands must be given to both programs, simple menu selections
    are not possible.</li>
    <li>The short block length causes throughput to suffer when used with
    timesharing systems, packet switched networks, satellite circuits, and
    buffered (error correcting) modems.</li>
    <li>The 8 bit checksum and unprotected supervison allow undetected errors
    and disrupted file transfers.</li>
    <li>Only one file can be sent per command. The file name has to be given
    twice, first to the sending program and then again to the receiving
    program.</li>
    <li>The transmitted file accumulates as many as 127 bytes of garbage.</li>
    <li>The modification date and other file attributes are lost.</li>
    <li>XMODEM requires complete 8 bit transparency, all 256 codes. XMODEM will
    not operate over some networks that use ASCII flow control or escape codes.
    Setting network transparency disables important control functions for the
    duration of the call.</li>
  </ul>

  <p>A number of other protocols have been developed over the years, but none
  have proven satisfactory.</p>

  <ul>
    <li>Lack of public domain documentation and example programs have kept
    proprietary protocols such as Relay, Blast, DART, and others tightly bound
    to the fortunes of their suppliers. These protocols have not benefited from
    public scrutiny of their design features.</li>
    <li>Link level protocols such as X.25, X.PC, and MNP do not manage
    application to application file transfers.</li>
    <li>Link Level protocols do not eliminate end-to-end errors. Interfaces
    between error-free networks are not necessarily error-free. Sometimes,
    error-free networks aren&#39;t.</li>
    <li>The Kermit protocol was developed to allow file transfers in
    environments hostile to XMODEM. The performance compromises necessary to
    accommodate traditional mainframe environments limit Kermit&#39;s
    efficiency. Even with completely transparent channels, Kermit control
    character quoting limits the efficiency of binary file transfers to about
    75 per cent.<a href="#IDR1" class="Footnote">[1]</a></li>
  </ul>

  <p>A number of submodes are used in various Kermit programs, including
  different methods of transferring binary files. Two Kermit programs will
  mysteriously fail to operate with each other if the user has not correctly
  specified these submodes.</p>

  <p>Kermit Sliding Windows (&quot;SuperKermit&quot;) improves throughput over
  networks at the cost of increased complexity. SuperKermit requires full
  duplex communications and the ability to check for the presence of characters
  in the input queue, precluding its implementation on some operating
  systems.</p>

  <p>SuperKermit state transitions are encoded in a special language
  &quot;wart&quot; which requires a C compiler.</p>

  <p>SuperKermit sends an ACK packet for each data packet of 96 bytes (fewer if
  control characters are present). This reduces throughput on high speed
  modems, from 1350 to 177 characters per second in one test.</p>

  <p>A number of extensions to the XMODEM protocol have been made to improve
  performance and (in some cases) the user interface. They provide useful
  improvements in some applications but not in others. XMODEM&#39;s unprotected
  control messages compromise their reliability. Complex proprietary techniques
  such as Cybernetic Data Recovery&trade;<a href="#IDR2" class="Footnote">[2]</a>
  improve reliability, but are not universally available. Some of the XMODEM
  mutant protocols have significant design flaws of their own.</p>

  <ul>
    <li>XMODEM-k uses 1024 byte blocks to reduce the overhead from transmission
    delays by 87 per cent compared to XMODEM, but network delays still degrade
    performance. Some networks cannot transmit 1024 byte packets without flow
    control, which is difficult to apply without impairing the perfect
    transparency required by XMODEM. XMODEM-k adds garbage to received
    files.</li>
    <li>YMODEM sends the file name, file length, and creation date at the
    beginning of each file, and allows optional 1024 byte blocks for improved
    throughput. The handling of files that are not a multiple of 1024 or 128
    bytes is awkward, especially if the file length is not known in advance, or
    changes during transmission. The large number of non conforming and
    substandard programs claiming to support YMODEM further complicates its
    use.</li>
    <li>YMODEM-g provides efficient batch file transfers, preserving exact file
    length and file modification date. YMODEM-g is a modification to YMODEM
    wherein ACKs for data blocks are not used. YMODEM-g is essentially
    insensitive to network delays. Because it does not support error recovery,
    YMODEM-g must be used hard wired or with a reliable link level protocol.
    Successful application at high speed requires cafeful attention to
    transparent flow control. When YMODEM-g detects a CRC error, data transfers
    are aborted. YMODEM-g is easy to implement because it closely resembles
    standard YMODEM-1k.</li>
    <li>WXMODEM, SEAlink, and MEGAlink have applied a subset of ZMODEM&#39;s
    techniques to &quot;Classic XMODEM&quot; to improve upon their
    suppliers&#39; previous offerings. They provide good performance under
    ideal conditions.</li>
  </ul>

  <p>Another XMODEM &quot;extension&quot; is protocol cheating, such as Omen
  Technology&#39;s OverThruster&trade; and OverThruster II&trade;. These
  improve XMODEM throughput under some conditions by compromising error
  recovery.</p>

  <p>The ZMODEM Protocol corrects the weaknesses described above while
  maintaining as much of XMODEM/CRC&#39;s simplicity and prior art as
  possible.</p>

  <h2><a name="ID3_" id="ID3_">3. ZMODEM Protocol Design Criteria</a></h2>

  <p>The design of a file transfer protocol is an engineering compromise
  between conflicting requirements:</p>

  <h3><a name="ID3_1_" id="ID3_1_">3.1 Ease of Use</a></h3>

  <ul>
    <li>ZMODEM allows either program to initiate file transfers.</li>
    <li>The sender can pass commands and/or modifiers to the receiving
    program.</li>
    <li>File names need be entered only once.</li>
    <li>Menu selections are supported.</li>
    <li>Wild Card names may be used with batch transfers.</li>
    <li>Minimum keystrokes required to initiate transfers.</li>
    <li>ZRQINIT frame sent by sending program can trigger automatic
    downloads.</li>
    <li>ZMODEM can optionally step down to YMODEM if the other end does not
    support ZMODEM.<a href="#IDR3" class="Footnote">[3]</a></li>
  </ul>

  <h3><a name="ID3_2_Throughput" id="ID3_2_Throughput">3.2 Throughput</a></h3>

  <p>All file transfer protocols make tradeoffs between throughput,
  reliability, universality, and complexity according to the technology and
  knowledge base available to their designers.</p>

  <p>In the design of ZMODEM, three applications deserve special attention.</p>

  <ul>
    <li>Network applications with significant delays (relative to character
    transmission time) and low error rate</li>
    <li>Timesharing and buffered modem applications with significant delays and
    throughput that is quickly degraded by reverse channel traffic.
    ZMODEM&#39;s economy of reverse channel bandwidth allows modems that
    dynamically partition bandwidth between the two directions to operate at
    optimal speeds. Special ZMODEM features allow simple, efficient
    implementation on a wide variety of timesharing hosts.</li>
    <li>Traditional direct modem to modem communications with high error
    rate</li>
  </ul>

  <p>Unlike Sliding Windows Kermit, ZMODEM is not optimized for optimum
  throughput when error rate and delays are both high. This tradeoff markedly
  reduces code complexity and memory requirements. ZMODEM generally provides
  faster error recovery than network compatible XMODEM implementations.</p>

  <p>In the absence of network delays, rapid error recovery is possible, much
  faster than MEGAlink and network compatible versions of YMODEM and
  XMODEM.</p>

  <p>File transfers begin immediately regardless of which program is started
  first, without the 10 second delay associated with XMODEM.</p>

  <h3><a name="ID3_3_" id="ID3_3_">3.3 Integrity and Robustness</a></h3>

  <p>Once a ZMODEM session is begun, all transactions are protected with 16 or
  32 bit CRC.<a href="#IDR4" class="Footnote">[4]</a> Complex proprietary techniques
  such as Omen Technology&#39;s Cybernetic Data Recovery&trade;<a href="#IDR5"
  class="Footnote">[5]</a> are not needed for reliable transfers. This complete
  protection of data and supervisory information accounts for most of
  ZMODEM&#39;s high reliability compared to XMODEM derived protocols including
  WXMODEM, SEAlink, MEGAlink, etc.</p>

  <p>An optional 32-bit CRC used as the frame check sequence in ADCCP (ANSI
  X3.66, also known as FIPS PUB 71 and FED-STD-1003, the U.S. versions of
  CCITT&#39;s X.25) is available. The 32 bit CRC reduces undetected errors by
  at least five orders of magnitude when properly applied (-1 preset,
  inversion).</p>

  <p>A security challenge mechanism guards against &quot;Trojan Horse&quot;
  messages written to mimic legitimate command or file downloads.</p>

  <h3><a name="ID3_4_" id="ID3_4_">3.4 Ease of Implementation</a></h3>

  <p>ZMODEM accommodates a wide variety of systems:</p>

  <ul>
    <li>Microcomputers that cannot overlap disk and serial i/o</li>
    <li>Microcomputers that cannot overlap serial send and receive</li>
    <li>Computers and/or networks requiring XON/XOFF flow control</li>
    <li>Computers that cannot check the serial input queue for the presence of
    data without having to wait for the data to arrive.</li>
  </ul>

  <p>Although ZMODEM provides &quot;hooks&quot; for multiple
  &quot;threads&quot;, ZMODEM is not intended to replace link level protocols
  such as X.25.</p>

  <p>ZMODEM accommodates network and timesharing system delays by continuously
  transmitting data unless the receiver interrupts the sender to request
  retransmission of garbled data. ZMODEM in effect uses the entire file as a
  window.<a href="#IDR6" class="Footnote">[6]</a> Using the entire file as a window
  simplifies buffer management, avoiding the window overrun failure modes that
  affect MEGAlink, SuperKermit, and others.</p>

  <p>ZMODEM provides a general purpose application to application file transfer
  protocol which may be used directly or with with reliable link level
  protocols such as X.25, MNP, Fastlink, etc. When used with X.25, MNP,
  Fastlink, etc., ZMODEM detects and corrects errors in the interfaces between
  error controlled media and the remainder of the communications link.</p>

  <p>ZMODEM was developed for the public domain under a Telenet contract. The
  ZMODEM protocol descriptions and the Unix rz/sz program source code are
  public domain. No licensing, trademark, or copyright restrictions apply to
  the use of the protocol, the Unix rz/sz source code and the ZMODEM name.</p>

  <h2><a name="ID4_" id="ID4_">4. Evolution Of ZMODEM</a></h2>

  <p>In early 1986, Telenet funded a project to develop an improved public
  domain application to application file transfer protocol. This protocol would
  alleviate the throughput problems network customers were experiencing with
  XMODEM and Kermit file transfers.</p>

  <p>In the beginning, we thought a few modifications to XMODEM would allow
  high performance over packet switched networks while preserving XMODEM&#39;s
  simplicity.</p>

  <p>The initial concept would add a block number to the ACK and NAK characters
  used by XMODEM. The resultant protocol would allow the sender to send more
  than one block before waiting for a response.</p>

  <p>But how to add the block number to XMODEM&#39;s ACK and NAK? WXMODEM,
  SEAlink, MEGAlink and some other protocols add binary byte(s) to indicate the
  block number.</p>

  <p>Pure binary was unsuitable for ZMODEM because binary code combinations
  won&#39;t pass bidirectionally through some modems, networks and operating
  systems. Other operating systems may not be able to recognize something
  coming back<a href="#IDR7" class="Footnote">[7]</a> unless a break signal or a
  system dependent code or sequence is present. By the time all this and other
  problems with the simple ACK/NAK sequences mentioned above were corrected,
  XMODEM&#39;s simple ACK and NACK characters had evolved into a real packet.
  The Frog was riveting.</p>

  <p>Managing the window<a href="#IDR8" class="Footnote">[8]</a> was another
  problem. Experience gained in debugging The Source&#39;s SuperKermit protocol
  indicated a window size of about 1000 characters was needed at 1200 bps. High
  speed modems require a window of 20000 or more characters for full
  throughput. Much of the SuperKermit&#39;s inefficiency, complexity and
  debugging time centered around its ring buffering and window management.
  There had to be a better way to get the job done.</p>

  <p>A sore point with XMODEM and its progeny is error recovery. More to the
  point, how can the receiver determine whether the sender has responded, or is
  ready to respond, to a retransmission request? XMODEM attacks the problem by
  throwing away characters until a certain period of silence. Too short a time
  allows a spurious pause in output (network or timesharing congestion) to
  masquerade as error recovery. Too long a timeout devastates throughput, and
  allows a noisy line to lock up the protocol. SuperKermit solves the problem
  with a distinct start of packet character (SOH). WXMODEM and ZMODEM use
  unique character sequences to delineate the start of frames. SEAlink and
  MEGAlink do not address this problem.</p>

  <p>A further error recovery problem arises in streaming protocols. How does
  the receiver know when (or if) the sender has recognized its error signal? Is
  the next packet the correct response to the error signal? Is it something
  left over &quot;in the queue&quot;? Or is this new subpacket one of many that
  will have to be discarded because the sender did not receive the error
  signal? How long should this continue before sending another error signal?
  How can the protocol prevent this from degenerating into an argument about
  mixed signals?</p>

  <p>SuperKermit uses selective retransmission, so it can accept any good
  packet it receives. Each time the SuperKermit receiver gets a data packet, it
  must decide which outstanding packet (if any) it &quot;wants most&quot; to
  receive, and asks for that one. In practice, complex software
  &quot;hacks&quot; are needed to attain acceptable robustness.<a href="#IDR9"
  class="Footnote">[9]</a></p>

  <p>For ZMODEM, we decided to forgo the complexity of SuperKermit&#39;s packet
  assembly scheme and its associated buffer management logic and memory
  requirements.</p>

  <p>Another sore point with XMODEM and WXMODEM is the garbage added to files.
  This was acceptable with the old CP/M files which had no exact length, but
  not with newer systems such as PC-DOS and Unix. YMODEM uses file length
  information transmitted in the header block to trim the output file, but this
  causes data loss when transferring files that grow during a transfer.</p>

  <p>In some cases, the file length may be unknown, as when data is obtained
  from a process. Variable length data subpackets solve both of these
  problems.</p>

  <p>Since some characters had to be escaped anyway, there wasn&#39;t any point
  wasting bytes to fill out a fixed packet length or to specify a variable
  packet length. In ZMODEM, the length of data subpackets is denoted by ending
  each subpacket with an escape sequence similar to BISYNC and HDLC.</p>

  <p>The end result is a ZMOEM header containing a &quot;frame type&quot;, four
  bytes of supervisory information, and its own CRC. Data frames consist of a
  header followed by 1 or more data subpackets. In the absence of transmission
  errors, an entire file can be sent in one data frame.</p>

  <p>Since the sending system may be sensitive to numerous control characters
  or strip parity in the reverse data path, all of the headers sent by the
  receiver are sent in hex. A common lower level routine receives all headers,
  allowing the main program logic to deal with headers and data subpackets as
  objects.</p>

  <p>With equivalent binary (efficient) and hex (application friendly) frames,
  the sending program can send an &quot;invitation to receive&quot; sequence to
  activate the receiver without crashing the remote application with unexpected
  control characters.</p>

  <p>Going &quot;back to scratch&quot; in the protocol design presents an
  opportunity to steal good ideas from many sources and to add a few new
  ones.</p>

  <p>From Kermit and UUCP comes the concept of an initial dialog to exchange
  system parameters.</p>

  <p>ZMODEM generalizes Compuserve B Protocol&#39;s host controlled transfers
  to single command AutoDownload and command downloading. A Security Challenge
  discourages password hackers and Trojan Horse authors from abusing
  ZMODEM&#39;s power.</p>

  <p>We were also keen to the pain and $uffering of legions of
  telecommunicators whose file transfers have been ruined by communications and
  timesharing faults. ZMODEM&#39;s file transfer recovery and advanced file
  management are dedicated to these kindred comrades.</p>

  <p>After ZMODEM had been operational a short time, Earl Hall pointed out the
  obvious: ZMODEM&#39;s user friendly AutoDownload was almost useless if the
  user must assign transfer options to each of the sending and receiving
  programs. Now, transfer options may be specified to/by the sending program,
  which passes them to the receiving program in the ZFILE header.</p>

  <h2><a name="ID5_" id="ID5_">5. Rosetta Stone</a></h2>

  <p>Here are some definitions which reflect current vernacular in the computer
  media. The attempt here is identify the file transfer protocol rather than
  specific programs.</p>

  <dl>
    <dt><b>FRAME</b></dt>
    <dd>A ZMODEM frame consists of a header and 0 or more data subpackets.</dd>
    <dt><b>XMODEM</b></dt>
    <dd>refers to the original 1977 file transfer etiquette introduced by Ward
    Christensen&#39;s MODEM2 program. It&#39;s also called the MODEM or MODEM2
    protocol. Some who are unaware of MODEM7&#39;s unusual batch file mode call
    it MODEM7. Other aliases include &quot;CP/M Users&#39;s Group&quot; and
    &quot;TERM II FTP 3&quot;. This protocol is supported by most
    communications programs because it is easy to implement.</dd>
    <dt><b>XMODEM/CRC</b></dt>
    <dd>replaces XMODEM&#39;s 1 byte checksum with a two byte Cyclical
    Redundancy Check (CRC-16), improving error detection.</dd>
    <dt><b>XMODEM-1k</b></dt>
    <dd>refers to XMODEM-CRC with optional 1024 byte blocks.</dd>
    <dt><b>YMODEM</b></dt>
    <dd>refers to the XMODEM/CRC protocol with batch transmission and optional
    1024 byte blocks as described in YMODEM.DOC.<a href="#IDR10"
    class="Footnote">[10]</a></dd>
  </dl>

  <h2><a name="ID6_" id="ID6_">6. ZMODEM Requirements</a></h2>

  <p>ZMODEM requires an 8 bit transfer medium.<a href="#IDR11"
  class="Footnote">[11]</a> ZMODEM escapes network control characters to allow
  operation with packet switched networks. In general, ZMODEM operates over any
  path that supports XMODEM, and over many that don&#39;t.</p>

  <p>To support full streaming,<a href="#IDR12" class="Footnote">[12]</a> the
  transmission path should either assert flow control or pass full speed
  transmission without loss of data. Otherwise the ZMODEM sender must manage
  the window size.</p>

  <h3><a name="ID6_1_" id="ID6_1_">6.1 File Contents</a></h3>

  <h4>6.1.1 Binary Files</h4>

  <p>ZMODEM places no constraints on the information content of binary files,
  except that the number of bits in the file must be a multiple of 8.</p>

  <h4>6.1.2 Text Files</h4>

  <p>Since ZMODEM is used to transfer files between different types of computer
  systems, text files must meet minimum requirements if they are to be readable
  on a wide variety of systems and environments.</p>

  <p>Text lines consist of printing ASCII characters, spaces, tabs, and
  backspaces.</p>

  <h5>6.1.2.1 ASCII End of Line</h5>

  <p>The ASCII code definition allows text lines terminated by a CR/LF (015,
  012) sequence, or by a NL (012) character. Lines logically terminated by a
  lone CR (013) are not <a href="ANSIX3_4-1986.htm">ASCII</a> text.</p>

  <p>A CR (013) without a linefeed implies overprinting, and is not acceptable
  as a logical line separator. Overprinted lines should print all important
  characters in the last pass to allow CRT displays to display meaningful text.
  Overstruck characters may be generated by backspacing or by overprinting the
  line with CR (015) not followed by LF.</p>

  <p>Overstruck characters generated with backspaces should be sent with the
  most important character last to accommodate CRT displays that cannot
  overstrike. The sending program may use the ZCNL bit to force the receiving
  program to convert the received end of line to its local end of line
  convention.<a href="#IDR13" class="Footnote">[13]</a></p>

  <h2><a name="ID7_" id="ID7_">7. ZMODEM Basics</a></h2>

  <h3><a name="ID7_1_Packetization" id="ID7_1_Packetization">7.1
  Packetization</a></h3>

  <p>ZMODEM frames differ somewhat from XMODEM blocks. XMODEM blocks are not
  used for the following reasons:</p>

  <ul>
    <li>Block numbers are limited to 256</li>
    <li>No provision for variable length blocks</li>
    <li>Line hits corrupt protocol signals, causing failed file transfers. In
    particular, modem errors sometimes generate false block numbers, false EOTs
    and false ACKs. False ACKs are the most troublesome as they cause the
    sender to lose synchronization with the receiver.</li>
  </ul>

  <blockquote>
    <p>State of the art programs such as Professional-YAM and ZCOMM overcome
    some of these weaknesses with clever proprietary code, but a stronger
    protocol is desired.</p>
  </blockquote>

  <ul>
    <li>&nbsp;It is difficult to determine the beginning and ends of XMODEM
    blocks when line hits cause a loss of synchronization. This precludes rapid
    error recovery.</li>
  </ul>

  <h3><a name="ID7_2_" id="ID7_2_">7.2 Link Escape Encoding</a></h3>

  <p>ZMODEM achieves data transparency by extending the
  <a href="KASCIICharTable.htm">8 bit character set</a> (256 codes) with escape
  sequences based on the ZMODEM data link escape character
  ZDLE.<a href="#IDR14" class="Footnote">[14]</a></p>

  <p>Link Escape coding permits variable length data subpackets without the
  overhead of a separate byte count. It allows the beginning of frames to be
  detected without special timing techniques, facilitating rapid error
  recovery.</p>

  <p>Link Escape coding does add some overhead. The worst case, a file
  consisting entirely of escaped characters, would incur a 50% overhead.</p>

  <p>The ZDLE character is special. ZDLE represents a control sequence of some
  sort. If a ZDLE character appears in binary data, it is prefixed with ZDLE,
  then sent as ZDLEE.</p>

  <p>The value for ZDLE is octal 030 (ASCII CAN). This particular value was
  chosen to allow a string of 5 consecutive CAN characters to abort a ZMODEM
  session, compatible with YMODEM session abort.</p>

  <p>Since CAN is not used in normal terminal operations, interactive
  applications and communications programs can monitor the data flow for ZDLE.
  The following characters can be scanned to detect the ZRQINIT header, the
  invitation to automatically download commands or files.</p>

  <p>Receipt of five successive CAN characters will abort a ZMODEM session.
  Eight CAN characters are sent.</p>

  <p>The receiving program decodes any sequence of ZDLE followed by a byte with
  bit 6 set and bit 5 reset (upper case letter, either parity) to the
  equivalent control character by inverting bit 6. This allows the transmitter
  to escape any control character that cannot be sent by the communications
  medium. In addition, the receiver recognizes escapes for 0177 and 0377 should
  these characters need to be escaped.</p>

  <p>ZMODEM software escapes ZDLE, 020, 0220, 021, 0221, 023, and 0223. If
  preceded by 0100 or 0300 (@), 015 and 0215 are also escaped to protect the
  Telenet command escape CR-@-CR. The receiver ignores 021, 0221, 023, and 0223
  characters in the data stream.</p>

  <p>The ZMODEM routines in <i>zm.c</i> accept an option to escape all control
  characters, to allow operation with less transparent networks. This option
  can be given to either the sending or receiving program.</p>

  <h3><a name="ID7_3_Header" id="ID7_3_Header">7.3 Header</a></h3>

  <p>All ZMODEM frames begin with a header which may be sent in binary or HEX
  form. ZMODEM uses a single routine to recognize binary and hex headers.
  Either form of the header contains the same raw information:</p>

  <ul>
    <li>A type byte<a href="#IDR15" class="Footnote">[15]</a> <a href="#IDR16"
    class="Footnote">[16]</a></li>
    <li>Four bytes of data indicating flags and/or numeric quantities depending
    on the frame type</li>
  </ul>

  <table summary="Order of Bytes in Header">
    <caption>
      <a name="Figure1" id="Figure1">Figure 1. Order of Bytes in Header</a>
    </caption>

    <tr>
      <td>
        <pre>
   TYPE:  frame type
   F0: Flags least significant byte
   P0: file Position least significant
   P3: file Position most significant
</pre>
      </td>
    </tr>

    <tr>
      <td>
        <pre>
       TYPE  F3 F2 F1 F0
       -------------------
       TYPE  P0 P1 P2 P3
</pre>
      </td>
    </tr>
  </table>

  <h4>7.3.1 16 Bit CRC Binary Header</h4>

  <p>A binary header is sent by the sending program to the receiving program.
  ZDLE encoding accommodates XON/XOFF flow control.</p>

  <p>A binary header begins with the sequence ZPAD, ZDLE, ZBIN.</p>

  <p>The frame type byte is ZDLE encoded.</p>

  <p>The four position/flags bytes are ZDLE encoded.</p>

  <p>A two byte CRC of the frame type and position/flag bytes is ZDLE
  encoded.</p>

  <p>0 or more binary data subpackets with 16 bit CRC will follow depending on
  the frame type.</p>

  <p>The function zsbhdr transmits a binary header. The function zgethdr
  receives a binary or hex header.</p>

  <p><a name="Figure2" id="Figure2">Figure 2. 16 Bit CRC Binary Header</a></p>
  <pre>
    * ZDLE A TYPE F3/P0    F2/P1 F1/P2 F0/P3 CRC-1 CRC-2
</pre>

  <h4>7.3.2 32 Bit CRC Binary Header</h4>

  <p>A &quot;32 bit CRC&quot; Binary header is similar to a Binary Header,
  except the ZBIN <b>&lt;A&gt;</b> character is replaced by a ZBIN32
  <b>&lt;C&gt;</b> character, and four characters of CRC are sent. 0 or more
  binary data subpackets with 32 bit CRC will follow depending on the frame
  type.</p>

  <p>The common variable Txfcs32 may be set TRUE for 32 bit CRC if the receiver
  indicates the capability with the CANFC32 bit. The zgethdr, zsdata and zrdata
  functions automatically adjust to the type of Frame Check Sequence being
  used.&nbsp;</p>

  <p><a name="Figure3" id="Figure3">Figure 3. 32 Bit CRC Binary Header</a></p>
  <pre>
      * ZDLE C TYPE F3/P0 F2/P1 F1/P2 F0/P3 CRC-1 CRC-2 CRC-3 CRC-4
</pre>

  <h4>7.3.3 HEX Header</h4>

  <p>The receiver sends responses in hex headers. The sender also uses hex
  headers when they are not followed by binary data subpackets.</p>

  <p>Hex encoding protects the reverse channel from random control characters.
  The hex header receiving routine ignores parity.</p>

  <p>Use of Kermit style encoding for control and paritied characters was
  considered and rejected because of increased possibility of interacting with
  some timesharing systems&#39; line edit functions. Use of HEX headers from
  the receiving program allows control characters to be used to interrupt the
  sender when errors are detected. A HEX header may be used in place of a
  binary header wherever convenient. If a data packet follows a HEX header, it
  is protected with CRC-16.</p>

  <p>A hex header begins with the sequence ZPAD, ZPAD, ZDLE, ZHEX. The zgethdr
  routine synchronizes with the ZPAD-ZDLE sequence. The extra ZPAD character
  allows the sending program to detect an asynchronous header (indicating an
  error condition) and then call zgethdr to receive the header.</p>

  <p>The type byte, the four position/flag bytes, and the 16 bit CRC thereof
  are sent in hex using the character set 01234567890abcdef. Upper case hex
  digits are not allowed; they false trigger XMODEM and YMODEM programs. Since
  this form of hex encoding detects many patterns of errors, especially missing
  characters, a hex header with 32 bit CRC has not been defined.</p>

  <p>A carriage return and line feed are sent with HEX headers. The receive
  routine expects to see at least one of these characters, two if the first is
  CR. The CR/LF aids debugging from printouts, and helps overcome certain
  operating system related problems.</p>

  <p>An XON character is appended to all HEX packets except ZACK and ZFIN. The
  XON releases the sender from spurious XOFF flow control characters generated
  by line noise, a common occurrence. XON is not sent after ZACK headers to
  protect flow control in streaming situations. XON is not sent after a ZFIN
  header to allow clean session cleanup.</p>

  <p>0 or more data subpackets will follow depending on the frame type.</p>

  <p>The function zshhdr sends a hex header.</p>

  <p><a name="Figure4" id="Figure4">Figure 4. HEX Header</a></p>
  <pre>
     *  * ZDLE B TYPE F3/P0 F2/P1 F1/P2 F0/P3 CRC-1 CRC-2 CR LF XON
</pre>

  <p>(TYPE, F3...F0, CRC-1, and CRC-2 are each sent as two hex digits.)</p>

  <h3><a name="ID7_4_" id="ID7_4_">7.4 Binary Data Subpackets</a></h3>

  <p>Binary data subpackets immediately follow the associated binary header
  packet. A binary data packet contains 0 to 1024 bytes of data. Recommended
  length values are 256 bytes below 2400 bps, 512 at 2400 bps, and 1024 above
  4800 bps or when the data link is known to be relatively error
  free.<a href="#IDR17" class="Footnote">[17]</a></p>

  <p>No padding is used with binary data subpackets. The data bytes are ZDLE
  encoded and transmitted. A ZDLE and frameend are then sent, followed by two
  or four ZDLE encoded CRC bytes. The CRC accumulates the data bytes and
  frameend.</p>

  <p>The function zsdata sends a data subpacket. The function zrdata receives a
  data subpacket.</p>

  <h3><a name="ID7_5_" id="ID7_5_">7.5 ASCII Encoded Data Subpacket</a></h3>

  <p>The format of ASCII Encoded data subpackets is not currently specified.
  These could be used for server commands, or main transfers in 7 bit
  environments.</p>

  <h2><a name="ID8_Protocol_Transaction_Overview"
  id="ID8_Protocol_Transaction_Overview">8. Protocol Transaction
  Overview</a></h2>

  <p>As with the XMODEM recommendation, ZMODEM timing is receiver driven. The
  transmitter should not time out at all, except to abort the program if no
  headers are received for an extended period of time, say one
  minute.<a href="#IDR18" class="Footnote">[18]</a></p>

  <h3><a name="ID8_1_" id="ID8_1_">8.1 Session Startup</a></h3>

  <p>To start a ZMODEM file transfer session, the sending program is called
  with the names of the desired file(s) and option(s).</p>

  <p>The sending program may send the string &quot;rz\r&quot; to invoke the
  receiving program from a possible command mode. The &quot;rz&quot; followed
  by carriage return activates a ZMODEM receive program or command if it were
  not already active.</p>

  <p>The sender may then display a message intended for human consumption, such
  as a list of the files requested, etc.</p>

  <p>Then the sender may send a ZRQINIT header. The ZRQINIT header causes a
  previously started receive program to send its ZRINIT header without
  delay.</p>

  <p>In an interactive or conversational mode, the receiving application may
  monitor the data stream for ZDLE. The following characters may be scanned for
  B00 indicating a ZRQINIT header, a command to download a command or data.</p>

  <p>The sending program awaits a command from the receiving program to start
  file transfers. If a &quot;C&quot;, &quot;G&quot;, or NAK is received, an
  XMODEM or YMODEM file transfer is indicated, and file transfer(s) use the
  YMODEM protocol. Note: With ZMODEM and YMODEM, the sending program provides
  the file name, but not with XMODEM.</p>

  <p>In case of garbled data, the sending program can repeat the invitation to
  receive a number of times until a session starts.</p>

  <p>When the ZMODEM receive program starts, it immediately sends a ZRINIT
  header to initiate ZMODEM file transfers, or a ZCHALLENGE header to verify
  the sending program. The receive program resends its header at response time
  (default 10 second) intervals for a suitable period of time (40 seconds
  total) before falling back to YMODEM protocol.</p>

  <p>If the receiving program receives a ZRQINIT header, it resends the ZRINIT
  header. If the sending program receives the ZCHALLENGE header, it places the
  data in ZP0...ZP3 in an answering ZACK header.</p>

  <p>If the receiving program receives a ZRINIT header, it is an echo
  indicating that the sending program is not operational.</p>

  <p>Eventually the sending program correctly receives the ZRINIT header.</p>

  <p>The sender may then send an optional ZSINIT frame to define the receiving
  program&#39;s Attn sequence, or to specify complete control character
  escaping.<a href="#IDR19" class="Footnote">[19]</a></p>

  <p>If the ZSINIT header specifies ESCCTL or ESC8, a HEX header is used, and
  the receiver activates the specified ESC modes before reading the following
  data subpacket.</p>

  <p>The receiver sends a ZACK header in response, containing either the serial
  number of the receiving program, or 0.</p>

  <h3><a name="ID8_2_" id="ID8_2_">8.2 File Transmission</a></h3>

  <p>The sender then sends a ZFILE header with ZMODEM Conversion, Management,
  and Transport options<a href="#IDR20" class="Footnote">[20]</a> followed by a
  ZCRCW data subpacket containing the file name, file length, modification
  date, and other information identical to that used by YMODEM Batch.</p>

  <p>The receiver examines the file name, length, and date information provided
  by the sender in the context of the specified transfer options, the current
  state of its file system(s), and local security requirements. The receiving
  program should insure the pathname and options are compatible with its
  operating environment and local security requirements.</p>

  <p>The receiver may respond with a ZSKIP header, which makes the sender
  proceed to the next file (if any) in the batch.</p>

  <p>The receiver has a file with the same name and length, may respond with a
  ZCRC header with a byte count, which requires the sender to perform a 32 bit
  CRC on the specified number of bytes in the file and transmit the complement
  of the CRC in an answering ZCRC header.<a href="#IDR21" class="Footnote">[21]</a>
  The receiver uses this information to determine whether to accept the file or
  skip it. This sequence may be triggered by the ZMCRC Management Option.</p>

  <p>A ZRPOS header from the receiver initiates transmission of the file data
  starting at the offset in the file specified in the ZRPOS header. Normally
  the receiver specifies the data transfer to begin begin at offset 0 in the
  file. The receiver may start the transfer further down in the file. This
  allows a file transfer interrupted by a loss or carrier or system crash to be
  completed on the next connection without requiring the entire file to be
  retransmitted.<a href="#IDR22" class="Footnote">[22]</a> If downloading a file
  from a timesharing system that becomes sluggish, the transfer can be
  interrupted and resumed later with no loss of data.</p>

  <p>The sender sends a ZDATA binary header (with file position) followed by
  one or more data subpackets.</p>

  <p>The receiver compares the file position in the ZDATA header with the
  number of characters successfully received to the file. If they do not agree,
  a ZRPOS error response is generated to force the sender to the right position
  within the file.<a href="#IDR23" class="Footnote">[23]</a></p>

  <p>A data subpacket terminated by ZCRCG and CRC does not elicit a response
  unless an error is detected; more data subpacket(s) follow immediately.</p>

  <p>ZCRCQ data subpackets expect a ZACK response with the receiver&#39;s file
  offset if no error, otherwise a ZRPOS response with the last good file
  offset. Another data subpacket continues immediately. ZCRCQ subpackets are
  not used if the receiver does not indicate FDX ability with the CANFDX
  bit.</p>

  <p>ZCRCW data subpackets expect a response before the next frame is sent. If
  the receiver does not indicate overlapped I/O capability with the CANOVIO
  bit, or sets a buffer size, the sender uses the ZCRCW to allow the receiver
  to write its buffer before sending more data.</p>

  <p>A zero length data frame may be used as an idle subpacket to prevent the
  receiver from timing out in case data is not immediately available to the
  sender.</p>

  <p>In the absence of fatal error, the sender eventually encounters end of
  file. If the end of file is encountered within a frame, the frame is closed
  with a ZCRCE data subpacket which does not elicit a response except in case
  of error.</p>

  <p>The sender sends a ZEOF header with the file ending offset equal to the
  number of characters in the file. The receiver compares this number with the
  number of characters received. If the receiver has received all of the file,
  it closes the file. If the file close was satisfactory, the receiver responds
  with ZRINIT. If the receiver has not received all the bytes of the file, the
  receiver ignores the ZEOF because a new ZDATA is coming. If the receiver
  cannot properly close the file, a ZFERR header is sent.</p>

  <p>After all files are processed, any further protocol errors should not
  prevent the sending program from returning with a success status.</p>

  <h3><a name="ID8_3_" id="ID8_3_">8.3 Session Cleanup</a></h3>

  <p>The sender closes the session with a ZFIN header. The receiver
  acknowledges this with its own ZFIN header.</p>

  <p>When the sender receives the acknowledging header, it sends two
  characters, &quot;OO&quot; (Over and Out) and exits to the operating system
  or application that invoked it. The receiver waits briefly for the
  &quot;O&quot; characters, then exits whether they were received or not.</p>

  <h3><a name="ID8_4_" id="ID8_4_">8.4 Session Abort Sequence</a></h3>

  <p>If the receiver is receiving data in streaming mode, the Attn sequence is
  executed to interrupt data transmission before the Cancel sequence is sent.
  The Cancel sequence consists of eight CAN characters and ten backspace
  characters. ZMODEM only requires five Cancel characters, the other three are
  &quot;insurance&quot;.</p>

  <p>The trailing backspace characters attempt to erase the effects of the CAN
  characters if they are received by a command interpreter.</p><code>static
  char canistr[] = { 24,24,24,24,24,24,24,24,8,8,8,8,8,8,8,8,8,8,0 };</code>

  <h2><a name="ID9_" id="ID9_">9. Streaming Techniques / Error
  Recovery</a></h2>

  <p>It is a fact of life that no single method of streaming is applicable to a
  majority of today&#39;s computing and telecommunications environments. ZMODEM
  provides several data streaming methods selected according to the limitations
  of the sending environment, receiving environment, and transmission
  channel(s).</p>

  <h3><a name="ID9_1_" id="ID9_1_">9.1 Full Streaming with Sampling</a></h3>

  <p>If the receiver can overlap serial I/O with disk I/O, and if the sender
  can sample the reverse channel for the presence of data without having to
  wait, full streaming can be used with no Attn sequence required. The sender
  begins data transmission with a ZDATA header and continuous ZCRCG data
  subpackets. When the receiver detects an error, it executes the Attn sequence
  and then sends a ZRPOS header with the correct position within the file.</p>

  <p>At the end of each transmitted data subpacket, the sender checks for the
  presence of an error header from the receiver. To do this, the sender samples
  the reverse data stream for the presence of either a ZPAD or CAN
  character.<a href="#IDR24" class="Footnote">[24]</a> Flow control characters (if
  present) are acted upon.</p>

  <p>Other characters (indicating line noise) increment a counter which is
  reset whenever the sender waits for a header from the receiver. If the
  counter overflows, the sender sends the next data subpacket as ZCRCW, and
  waits for a response.</p>

  <p>ZPAD indicates some sort of error header from the receiver. A CAN suggests
  the user is attempting to &quot;stop the bubble machine&quot; by keyboarding
  CAN characters. If one of these characters is seen, an empty ZCRCE data
  subpacket is sent. Normally, the receiver will have sent an ZRPOS or other
  error header, which will force the sender to resume transmission at a
  different address, or take other action. In the unlikely event the ZPAD or
  CAN character was spurious, the receiver will time out and send a ZRPOS
  header.<a href="#IDR25" class="Footnote">[25]</a></p>

  <p>Then the receiver&#39;s response header is read and acted
  upon.<a href="#IDR26" class="Footnote">[26]</a></p>

  <p>A ZRPOS header resets the sender&#39;s file offset to the correct
  position. If possible, the sender should purge its output buffers and/or
  networks of all unprocessed output data, to minimize the amount of unwanted
  data the receiver must discard before receiving data starting at the correct
  file offset. The next transmitted data frame should be a ZCRCW frame followed
  by a wait to guarantee complete flushing of the network&#39;s memory.</p>

  <p>If the receiver gets a ZACK header with an address that disagrees with the
  sender address, it is ignored, and the sender waits for another header. A
  ZFIN, ZABORT, or TIMEOUT terminates the session; a ZSKIP terminates the
  processing of this file.</p>

  <p>The reverse channel is then sampled for the presence of another header
  from the receiver.<a href="#IDR27" class="Footnote">[27]</a> if one is detected,
  the <code>getinsync()</code> function is again called to read another error
  header. Otherwise, transmission resumes at the (possibly reset) file offset
  with a ZDATA header followed by data subpackets.</p>

  <h4>9.1.1 Window Management</h4>

  <p>When sending data through a network, some nodes of the network store data
  while it is transferred to the receiver. 7000 bytes and more of transient
  storage have been observed. Such a large amount of storage causes the
  transmitter to &quot;get ahead&quot; of the reciever. This can be fatal with
  MEGAlink and other protocols that depend on timely notification of errors
  from the receiver. This condition is not fatal with ZMODEM, but it does slow
  error recovery.</p>

  <p>To manage the window size, the sending program uses ZCRCQ data subpackets
  to trigger ZACK headers from the receiver. The returning ZACK headers inform
  the sender of the receiver&#39;s progress. When the window size (current
  transmitter file offset - last reported receiver file offset) exceeds a
  specified value, the sender waits for a ZACK<a href="#IDR28"
  class="Footnote">[28]</a> packet with a receiver file offset that reduces the
  window size.</p>

  <p>Unix sz versions beginning with May 9 1987 control the window size with
  the &quot;-w N&quot; option, where N is the maximum window size. Pro-YAM,
  ZCOMM and DSZ versions beginning with May 9 1987 control the window size with
  &quot;zmodem pwN&quot;. This is compatible with previous versions of these
  programs.<a href="#IDR29" class="Footnote">[29]</a></p>

  <h3><a name="ID9_2_" id="ID9_2_">9.2 Full Streaming with Reverse
  Interrupt</a></h3>The above method cannot be used if the reverse data stream
  cannot be sampled without entering an I/O wait. An alternate method is to
  instruct the receiver to interrupt the sending program when an error is
  detected.

  <p>The receiver can interrupt the sender with a control character, break
  signal, or combination thereof, as specified in the Attn sequence. After
  executing the Attn sequence, the receiver sends a hex ZRPOS header to force
  the sender to resend the lost data.</p>

  <p>When the sending program responds to this interrupt, it reads a HEX header
  (normally ZRPOS) from the receiver and takes the action described in the
  previous section. The Unix sz.c program uses a setjmp/longjmp call to catch
  the interrupt generated by the Attn sequence. Catching the interrupt
  activates the getinsync() function to read the receiver&#39;s error header
  and take appropriate action.</p>

  <p>When compiled for standard SYSTEM III/V Unix, sz.c uses an Attn sequence
  of Ctrl-C followed by a 1 second pause to interrupt the sender, then give the
  sender (Unix) time to prepare for the receiver&#39;s error header.</p>

  <h3><a name="ID9_3_" id="ID9_3_">9.3 Full Streaming with Sliding
  Window</a></h3>

  <p>If none of the above methods is applicable, hope is not yet lost. If the
  sender can buffer responses from the receiver, the sender can use ZCRCQ data
  subpackets to get ACKs from the receiver without interrupting the
  transmission of data. After a sufficient number of ZCRCQ data subpackets have
  been sent, the sender can read one of the headers that should have arrived in
  its receive interrupt buffer.</p>

  <p>A problem with this method is the possibility of wasting an excessive
  amount of time responding to the receiver&#39;s error header. It may be
  possible to program the receiver&#39;s Attn sequence to flush the
  sender&#39;s interrupt buffer before sending the ZRPOS header.</p>

  <p><i>Note:</i> control with XON and XOFF characters and pass XON characters
  that violate flow control, the receiving program should have a revision date
  of May 9 or later.</p>

  <h3><a name="ID9_4_" id="ID9_4_">9.4 Full Streaming over Error Free
  Channels</a></h3>

  <p>File transfer protocols predicated on the existence of an error free end
  to end communications channel have been proposed from time to time. Such
  channels have proven to be more readily available in theory than in
  actuality. The frequency of undetected errors increases when modem scramblers
  have more bits than the error detecting CRC.</p>

  <p>A ZMODEM sender assuming an error free channel with end to end flow
  control can send the entire file in one frame without any checking of the
  reverse stream. If this channel is completely transparent, only ZDLE need be
  escaped. The resulting protocol overhead for average long files is less than
  one per cent.<a href="#IDR30" class="Footnote">[30]</a></p>

  <h3><a name="ID9_5_" id="ID9_5_">9.5 Segmented Streaming</a></h3>

  <p>If the receiver cannot overlap serial and disk I/O, it uses the ZRINIT
  frame to specify a buffer length which the sender will not overflow. The
  sending program sends a ZCRCW data subpacket and waits for a ZACK header
  before sending the next segment of the file.</p>

  <p>If the sending program supports reverse data stream sampling or interrupt,
  error recovery will be faster (on average) than a protocol (such as YMODEM)
  that sends large blocks.</p>

  <p>A sufficiently large receiving buffer allows throughput to closely
  approach that of full streaming. For example, 16kb segmented streaming adds
  about 3 per cent to full streaming ZMODEM file transfer times when the round
  trip delay is five seconds.</p>

  <h2><a name="ID10_" id="ID10_">10. Attention Sequence</a></h2>

  <p>The receiving program sends the Attn sequence whenever it detects an error
  and needs to interrupt the sending program.</p>

  <p>The default Attn string value is empty (no Attn sequence). The receiving
  program resets Attn to the empty default before each transfer session.</p>

  <p>The sender specifies the Attn sequence in its optional ZSINIT frame. The
  Attn string is terminated with a null.</p>

  <p>Two meta-characters perform special functions:</p>

  <ul>
    <li>&nbsp;\335 (octal) Send a break signal</li>
    <li>&nbsp;\336 (octal) Pause one second</li>
  </ul>

  <h2><a name="ID11_" id="ID11_">11. Frame Types</a></h2>

  <p>The numeric values for the values shown in boldface are given in
  <i>zmodem.h</i>. Unused bits and unused bytes in the header (ZP0...ZP3) are
  set to 0.</p>

  <h3><a name="ID11_1_ZRQINIT" id="ID11_1_ZRQINIT">11.1 ZRQINIT</a></h3>

  <p>Sent by the sending program, to trigger the receiving program to send its
  ZRINIT header. This avoids the aggravating startup delay associated with
  XMODEM and Kermit transfers. The sending program may repeat the receive
  invitation (including ZRQINIT) if a response is not obtained at first.</p>

  <p>ZF0 contains ZCOMMAND if the program is attempting to send a command, 0
  otherwise.</p>

  <h3><a name="ID11_2_ZRINIT" id="ID11_2_ZRINIT">11.2 ZRINIT</a></h3>

  <p>Sent by the receiving program. ZF0 and ZF1 contain the bitwise or of the
  receiver capability flags:</p>
  <pre class="Code">
#define       CANCRY      8   /* Receiver can decrypt */
#define CANFDX     01   /* Rx can send and receive true FDX */
#define CANOVIO    02   /* Rx can receive data during disk I/O */
#define CANBRK     04   /* Rx can send a break signal */
#define CANCRY    010   /* Receiver can decrypt */
#define CANLZW    020   /* Receiver can uncompress */
#define CANFC32   040   /* Receiver can use 32 bit Frame Check */
#define ESCCTL   0100   /* Receiver expects ctl chars to be escaped*/
#define ESC8     0200   /* Receiver expects 8th bit to be escaped */
</pre>

  <p>ZP0 and ZP1 contain the size of the receiver&#39;s buffer in bytes, or 0
  if nonstop I/O is allowed.</p>

  <h3><a name="ID11_3_ZSINIT" id="ID11_3_ZSINIT">11.3 ZSINIT</a></h3>

  <p>The Sender sends flags followed by a binary data subpacket terminated with
  ZCRCW.</p>
  <pre class="Code">
/* Bit Masks for ZSINIT       flags byte ZF0 */
#define TESCCTL 0100   /* Transmitter expects ctl chars to be escaped*/
#define TESC8   0200   /* Transmitter expects 8th bit to be escaped*/
</pre>

  <p>The data subpacket contains the null terminated Attn sequence, maximum
  length 32 bytes including the terminating null.</p>

  <h3><a name="ID11_4_ZACK" id="ID11_4_ZACK">11.4 ZACK</a></h3>

  <p>Acknowledgment to a ZSINIT frame, ZCHALLENGE header, ZCRCQ or ZCRCW data
  subpacket. ZP0 to ZP3 contain file offset. The response to ZCHALLENGE
  contains the same 32 bit number received in the ZCHALLENGE header.</p>

  <h3><a name="ID11_5_ZFILE" id="ID11_5_ZFILE">11.5 ZFILE</a></h3>

  <p>This frame denotes the beginning of a file transmission attempt. ZF0, ZF1,
  and ZF2 may contain options. A value of 0 in each of these bytes implies no
  special treatment. Options specified to the receiver override options
  specified to the sender with the exception of ZCBIN. A ZCBIN from the sender
  overrides any other Conversion Option given to the receiver except ZCRESUM. A
  ZCBIN from the receiver overrides any other Conversion Option sent by the
  sender.</p>

  <h4><a name="11.5.1_ZF0" id="11.5.1_ZF0">11.5.1 ZF0</a></h4>

  <p>ZFO: Conversion Option If the receiver does not recognize the Conversion
  Option, an application dependent default conversion may apply.</p>

  <ul>
    <li>ZCBIN &quot;Binary&quot; transfer - inhibit conversion
    unconditionally</li>
    <li>ZCNL Convert received end of line to local end of line convention. The
    supported end of line conventions are CR/LF (most ASCII based operating
    systems except Unix and Macintosh), and NL (Unix). Either of these two end
    of line conventions meet the permissible ASCII definitions for Carriage
    Return and Line Feed/New Line. Neither the ASCII code nor ZMODEM ZCNL
    encompass lines separated only by carriage returns. Other processing
    appropriate to ASCII text files and the local operating system may also be
    applied by the receiver.<a href="#IDR31" class="Footnote">[31]</a></li>
    <li>ZCRECOV Recover/Resume interrupted file transfer. ZCREVOV is also
    useful for updating a remote copy of a file that grows without resending of
    old data. If the destination file exists and is no longer than the source,
    append to the destination file and start transfer at the offset
    corresponding to the receiver&#39;s end of file. This option does not apply
    if the source file is shorter. Files that have been converted (e.g., ZCNL)
    or subject to a single ended Transport Option cannot have their transfers
    recovered.</li>
  </ul>

  <h4><a name="11.5.2_ZF1" id="11.5.2_ZF1">11.5.2 ZF1</a></h4>

  <p>ZF1: Management Option If the receiver does not recognize the Management
  Option, the file should be transferred normally.</p>

  <p>The ZMSKNOLOC bit instructs the receiver to bypass the current file if the
  receiver does not have a file with the same name.</p>

  <p>Five bits (defined by ZMMASK) define the following set of mutually
  exclusive management options.</p>

  <ul>
    <li>ZMNEWL Transfer file if destination file absent. Otherwise, transfer
    file overwriting destination if the source file is newer or longer.</li>
    <li>ZMCRC Compare the source and destination files. Transfer if file
    lengths or file polynomials differ.</li>
    <li>ZMAPND Append source file contents to the end of the existing
    destination file (if any).</li>
    <li>ZMCLOB Replace existing destination file (if any).</li>
    <li>ZMDIFF Transfer file if destination file absent. Otherwise, transfer
    file overwriting destination if files have different lengths or dates.</li>
    <li>ZMPROT Protect destination file by transferring file only if the
    destination file is absent.</li>
    <li>ZMNEW Transfer file if destination file absent. Otherwise, transfer
    file overwriting destination if the source file is newer.</li>
  </ul>

  <h4><a name="11.5.3_ZF2" id="11.5.3_ZF2">11.5.3 ZF2</a></h4>

  <p>ZF2: Transport Option If the receiver does not implement the particular
  transport option, the file is copied without conversion for later
  processing.</p>

  <ul>
    <li>ZTLZW Lempel-Ziv compression. Transmitted data will be identical to
    that produced by compress 4.0 operating on a computer with VAX byte
    ordering, using 12 bit encoding.</li>
    <li>ZTCRYPT Encryption. An initial null terminated string identifies the
    key. Details to be determined.</li>
    <li>ZTRLE Run Length encoding, Details to be determined.</li>
  </ul>

  <p>A ZCRCW data subpacket follows with file name, file length, modification
  date, and other information described in a later chapter.</p>

  <h4><a name="11.5.4_ZF3" id="11.5.4_ZF3">11.5.4 ZF3</a></h4>

  <p>ZF3: Extended Options The Extended Options are bit encoded.</p>

  <p>ZTSPARS Special processing for sparse files, or sender managed selective
  retransmission. Each file segment is transmitted as a separate frame, where
  the frames are not necessarily contiguous. The sender should end each segment
  with a ZCRCW data subpacket and process the expected ZACK to insure no data
  is lost. ZTSPARS cannot be used with ZCNL.</p>

  <h4><a name="ID11_6_ZSKIP" id="ID11_6_ZSKIP">11.6 ZSKIP</a></h4>

  <p>Sent by the receiver in response to ZFILE, makes the sender skip to the
  next file.</p>

  <h4><a name="ID11_7_ZNAK" id="ID11_7_ZNAK">11.7 ZNAK</a></h4>

  <p>Indicates last header was garbled. (See also
  <a href="#ID11_10_ZRPOS">ZRPOS</a>).</p>

  <h4><a name="ID11_8_ZABORT" id="ID11_8_ZABORT">11.8 ZABORT</a></h4>

  <p>Sent by receiver to terminate batch file transfers when requested by the
  user. Sender responds with a ZFIN sequence.<a href="#IDR32"
  class="Footnote">[32]</a></p>

  <h4><a name="ID11_9_ZFIN" id="ID11_9_ZFIN">11.9 ZFIN</a></h4>

  <p>Sent by sending program to terminate a ZMODEM session. Receiver responds
  with its own ZFIN.</p>

  <h4><a name="ID11_10_ZRPOS" id="ID11_10_ZRPOS">11.10 ZRPOS</a></h4>

  <p>Sent by receiver to force file transfer to resume at file offset given in
  ZP0...ZP3.</p>

  <h4><a name="ID11_11_ZDATA" id="ID11_11_ZDATA">11.11 ZDATA</a></h4>

  <p>ZP0...ZP3 contain file offset. One or more data subpackets follow.</p>

  <h4><a name="ID11_12_ZEOF" id="ID11_12_ZEOF">11.12 ZEOF</a></h4>

  <p>Sender reports End of File. ZP0...ZP3 contain the ending file offset.</p>

  <h4><a name="ID11_13_ZFERR" id="ID11_13_ZFERR">11.13 ZFERR</a></h4>Error in
  reading or writing file, protocol equivalent to ZABORT.

  <h4><a name="ID11_14_ZCRC" id="ID11_14_ZCRC">11.14 ZCRC</a></h4>

  <p>Request (receiver) and response (sender) for file polynomial. ZP0...ZP3
  contain file polynomial.</p>

  <h4><a name="ID11_15_ZCHALLENGE" id="ID11_15_ZCHALLENGE">11.15
  ZCHALLENGE</a></h4>

  <p>Request sender to echo a random number in ZP0...ZP3 in a ZACK frame. Sent
  by the receiving program to the sending program to verify that it is
  connected to an operating program, and was not activated by spurious data or
  a Trojan Horse message.</p>

  <h4><a name="ID11_16_ZCOMPL" id="ID11_16_ZCOMPL">11.16 ZCOMPL</a></h4>

  <p>Request now completed.</p>

  <h4><a name="ID11_17_ZCAN" id="ID11_17_ZCAN">11.17 ZCAN</a></h4>

  <p>This is a pseudo frame type returned by gethdr() in response to a Session
  Abort sequence.</p>

  <h4><a name="ID11_18_ZFREECNT" id="ID11_18_ZFREECNT">11.18 ZFREECNT</a></h4>

  <p>Sending program requests a ZACK frame with ZP0...ZP3 containing the number
  of free bytes on the current file system. A value of 0 represents an
  indefinite amount of free space.</p>

  <h4><a name="ID11_19_ZCOMMAND" id="ID11_19_ZCOMMAND">11.19 ZCOMMAND</a></h4>

  <p>ZCOMMAND is sent in a binary frame. ZF0 contains 0 or ZCACK1 (see
  below).</p>

  <p>A ZCRCW data subpacket follows, with the ASCII text command string
  terminated with a NULL character. If the command is intended to be executed
  by the operating system hosting the receiving program (e.g., &quot;shell
  escape&quot;), it must have &quot;!&quot; as the first character. Otherwise
  the command is meant to be executed by the application program which receives
  the command.</p>

  <p>If the receiver detects an illegal or badly formed command, the receiver
  immediately responds with a ZCOMPL header with an error code in
  ZP0...ZP3.</p>

  <p>If ZF0 contained ZCACK1, the receiver immediately responds with a ZCOMPL
  header with 0 status.</p>

  <p>Otherwise, the receiver responds with a ZCOMPL header when the operation
  is completed. The exit status of the completed command is stored in
  ZP0...ZP3. A 0 exit status implies nominal completion of the command.</p>

  <p>If the command causes a file to be transmitted, the command sender will
  see a ZRQINIT frame from the other computer attempting to send data.</p>

  <p>The sender examines ZF0 of the received ZRQINIT header to verify it is not
  an echo of its own ZRQINIT header. It is illegal for the sending program to
  command the receiving program to send a command.</p>

  <p>If the receiver program does not implement command downloading, it may
  display the command to the standard error output, then return a ZCOMPL
  header.</p>

  <h2><a name="ID12_" id="ID12_">12. Session Transaction Examples</a></h2>

  <h3><a name="ID12_1_" id="ID12_1_">12.1 A simple file transfer</a></h3>

  <p>A simple transaction, one file, no errors, no CHALLENGE, overlapped
  I/O:</p>

  <blockquote>
    <table border="0" summary="One file transaction">
      <tr>
        <th>Sender</th>
        <th>Receiver</th>
      </tr>

      <tr>
        <td>&quot;rz\r&quot;</td>
        <td>&nbsp;</td>
      </tr>

      <tr>
        <td>ZRQINIT(0)</td>
        <td>&nbsp;</td>
      </tr>

      <tr>
        <td>&nbsp;</td>
        <td>ZRINIT</td>
      </tr>

      <tr>
        <td>ZFILE</td>
        <td>&nbsp;</td>
      </tr>

      <tr>
        <td>&nbsp;</td>
        <td>ZRPOS</td>
      </tr>

      <tr>
        <td>ZDATA data &hellip;</td>
        <td>&nbsp;</td>
      </tr>

      <tr>
        <td>ZEOF</td>
        <td>&nbsp;</td>
      </tr>

      <tr>
        <td>&nbsp;</td>
        <td>ZRINIT</td>
      </tr>

      <tr>
        <td>ZFIN</td>
        <td>&nbsp;</td>
      </tr>

      <tr>
        <td>&nbsp;</td>
        <td>ZFIN</td>
      </tr>

      <tr>
        <td>OO</td>
        <td>&nbsp;</td>
      </tr>
    </table>
  </blockquote>

  <h3><a name="ID12_2_" id="ID12_2_">12.2 Challenge and Command
  Download</a></h3>

  <blockquote>
    <table border="0" summary="Challenge and Command">
      <tr>
        <th>Sender</th>
        <th>Receiver</th>
      </tr>

      <tr>
        <td>&quot;rz\r&quot;</td>
        <td>&nbsp;</td>
      </tr>

      <tr>
        <td>ZRQINIT(ZCOMMAND)</td>
        <td>&nbsp;</td>
      </tr>

      <tr>
        <td>&nbsp;</td>
        <td>ZCHALLENGE(random-number)</td>
      </tr>

      <tr>
        <td>ZACK(same-number)</td>
        <td>&nbsp;</td>
      </tr>

      <tr>
        <td>&nbsp;</td>
        <td>ZRINIT</td>
      </tr>

      <tr>
        <td>ZCOMMAND, ZDATA</td>
        <td>&nbsp;</td>
      </tr>

      <tr>
        <td>&nbsp;</td>
        <td>(Performs Command)</td>
      </tr>

      <tr>
        <td>&nbsp;</td>
        <td>ZCOMPL</td>
      </tr>

      <tr>
        <td>ZFIN</td>
        <td>&nbsp;</td>
      </tr>

      <tr>
        <td>&nbsp;</td>
        <td>ZFIN</td>
      </tr>

      <tr>
        <td>OO</td>
        <td>&nbsp;</td>
      </tr>
    </table>
  </blockquote>

  <h2><br />
   <a name="ID13_" id="ID13_">13. ZFILE Frame File Information</a></h2>

  <p>ZMODEM sends the same file information with the ZFILE frame data that
  YMODEM Batch sends in its block 0.</p>

  <p class="Note">N.B.: The pathname (file name) field is mandatory.</p>

  <p>Pathname The pathname (conventionally, the file name) is sent as a null
  terminated ASCII string. This is the filename format used by the handle
  oriented MSDOS&trade; functions and C library fopen functions. An assembly
  language example follows: DB &#39;foo.bar&#39;,0 No spaces are included in
  the pathname. Normally only the file name stem (no directory prefix) is
  transmitted unless the sender has selected YAM&#39;s f option to send the
  full absolute or relative pathname. The source drive designator (A:, B:,
  etc.) usually is not sent.</p>

  <p>Filename Considerations</p>

  <ul>
    <li>File names should be translated to lower case unless the sending system
    supports upper/lower case file names. This is a convenience for users of
    systems (such as Unix) which store filenames in upper and lower case.</li>
    <li>The receiver should accommodate file names in lower and upper
    case.</li>
    <li>When transmitting files between different operating systems, file names
    must be acceptable to both the sender and receiving operating systems. If
    not, transformations should be applied to make the file names acceptable.
    If the transformations are unsuccessful, a new file name may be invented be
    the receiving program.</li>
  </ul>

  <p>If directories are included, they are delimited by /; i.e.,
  &quot;<code>subdir/foo</code>&quot; is acceptable,
  &quot;<code>subdir\foo</code>&quot; is not.</p>

  <dl>
    <dt><b>Length</b></dt>
    <dd>
      The file length and each of the succeeding fields are
      optional.<a href="#IDR33" class="Footnote">[33]</a> The length field is stored
      as a decimal string counting the number of data bytes in the file.

      <p>The ZMODEM receiver uses the file length as an estimate only. It may
      be used to display an estimate of the transmission time, and may be
      compared with the amount of free disk space. The actual length of the
      received file is determined by the data transfer. A file may grow after
      transmission commences, and all the data will be sent.</p>
    </dd>
    <dt><b>Modification Date</b></dt>
    <dd>
      A single space separates the modification date from the file
      length.

      <p>The mod date is optional, and the filename and length may be sent
      without requiring the mod date to be sent.</p>

      <p>The mod date is sent as an octal number giving the time the contents
      of the file were last changed measured in seconds from Jan 1 1970
      Universal Coordinated Time (GMT). A date of 0 implies the modification
      date is unknown and should be left as the date the file is received.</p>

      <p>This standard format was chosen to eliminate ambiguities arising from
      transfers between different time zones.</p>
    </dd>
    <dt><b>File Mode</b></dt>
    <dd>A single space separates the file mode from the modification date. The
    file mode is stored as an octal string. Unless the file originated from a
    Unix system, the file mode is set to 0. rz(1) checks the file mode for the
    0x8000 bit which indicates a Unix type regular file. Files with the 0x8000
    bit set are assumed to have been sent from another Unix (or similar) system
    which uses the same file conventions. Such files are not translated in any
    way.</dd>
    <dt><b>Serial Number</b></dt>
    <dd>A single space separates the serial number from the file mode. The
    serial number of the transmitting program is stored as an octal string.
    Programs which do not have a serial number should omit this field, or set
    it to 0. The receiver&#39;s use of this field is optional.</dd>
    <dt><b>Number of Files Remaining</b></dt>
    <dd>If the number of files remaining is sent, a single space separates this
    field from the previous field. This field is coded as a decimal number, and
    includes the current file. This field is an estimate, and incorrect values
    must not be allowed to cause loss of data. The receiver&#39;s use of this
    field is optional.</dd>
    <dt><b>Number of Bytes Remaining</b></dt>
    <dd>If the number of bytes remaining is sent, a single space separates this
    field from the previous field. This field is coded as a decimal number, and
    includes the current file. This field is an estimate, and incorrect values
    must not be allowed to cause loss of data. The receiver&#39;s use of this
    field is optional.</dd>
    <dt><b>File Type</b></dt>
    <dd>
      If the file type is sent, a single space separates this field from the
      previous field. This field is coded as a decimal number. Currently
      defined values are:

      <ul>
        <li>0 Sequential file - no special type</li>
        <li>1 Other types to be defined. The receiver&#39;s use of this field
        is optional.</li>
      </ul>
    </dd>
  </dl>

  <p>The file information is terminated by a null. If only the pathname is
  sent, the pathname is terminated with two nulls. The length of the file
  information subpacket, including the trailing null, must not exceed 1024
  bytes; a typical length is less than 64 bytes.</p>

  <h2><a name="ID14_" id="ID14_">14. Performance Results</a></h2>

  <h3><a name="ID14_1_Compatibility" id="ID14_1_Compatibility">14.1
  Compatibility</a></h3>Extensive testing has demonstrated ZMODEM to be
  compatible with satellite links, packet switched networks, microcomputers,
  minicomputers, regular and error correcting buffered modems at 75 to 19200
  bps. ZMODEM&#39;s economy of reverse channel bandwidth allows modems that
  dynamically partition bandwidth between the two directions to operate at
  optimal speeds.

  <h3><a name="ID14_2_Throughput" id="ID14_2_Throughput">14.2
  Throughput</a></h3>

  <p>Between two single task PC-XT computers sending a program image on an in
  house Telenet link, SuperKermit provided 72 ch/sec throughput at 1200 baud.
  YMODEM-k yielded 85 chars/sec, and ZMODEM provided 113 chars/sec. XMODEM was
  not measured, but would have been much slower based on observed network
  propagation delays.</p>

  <p>Recent tests downloading large binary files to an IBM PC (4.7 mHz V20)
  running YAMK 16.30 with table driven 32 bit CRC calculation yielded a
  throughput of 1870 cps on a 19200 bps direct connection.</p>

  <p>Tests with TELEBIT TrailBlazer modems have shown transfer rates
  approaching 1400 characters per second for long files. When files are
  compressed, effective transfer rates of 2000 characters per second are
  possible.</p>

  <h3><a name="ID14_3_" id="ID14_3_">14.3 Error Recovery</a></h3>

  <p>Some tests of ZMODEM protocol error recovery performance have been made. A
  PC-AT with SCO SYS V Xenix or DOS 3.1 was connected to a PC with DOS 2.1
  either directly at 9600 bps or with unbuffered dial-up 1200 bps modems. The
  ZMODEM software was configured to use 1024 byte data subpacket lengths above
  2400 bps, 256 otherwise.</p>

  <p>Because no time delays are necessary in normal file transfers, per file
  negotiations are much faster than with YMODEM, the only observed delay being
  the time required by the program(s) to update logging files.</p>

  <p>During a file transfer, a short line hit seen by the receiver usually
  induces a CRC error. The interrupt sequence is usually seen by the sender
  before the next data subpacket is completely sent, and the resultant loss of
  data throughput averages about half a data subpacket per line hit. At 1200
  bps this is would be about .75 second lost per hit. At 10-5 error rate, this
  would degrade throughput by about 9 per cent.</p>

  <p>The throughput degradation increases with increasing channel delay, as
  more data subpackets in transit through the channel are discarded when an
  error is detected.</p>

  <p>A longer noise burst that affects both the receiver and the sender&#39;s
  reception of the interrupt sequence usually causes the sender to remain
  silent until the receiver times out in 10 seconds. If the round trip channel
  delay exceeds the receiver&#39;s 10 second timeout, recovery from this type
  of error may become difficult.</p>

  <p>Noise affecting only the sender is usually ignored, with one common
  exception. Spurious XOFF characters generated by noise stop the sender until
  the receiver times out and sends an interrupt sequence which concludes with
  an XON.</p>

  <p>In summation, ZMODEM performance in the presence of errors resembles that
  of X.PC and SuperKermit. Short bursts cause minimal data retransmission. Long
  bursts (such as pulse dialing noises) often require a timeout error to
  restore the flow of data.</p>

  <h2><a name="ID15_" id="ID15_">15. Packet Switched Network
  Considerations</a></h2>

  <p>Flow control is necessary for printing messages and directories, and for
  streaming file transfer protocols. A non transparent flow control is
  incompatible with XMODEM and YMODEM transfers. XMODEM and YMODEM protocols
  require complete transparency of all 256 8 bit codes to operate properly.</p>

  <p>The &quot;best&quot; flow control (when X.25 or hardware CTS is
  unavailable) would not &quot;eat&quot; any characters at all. When the
  PAD&#39;s buffer almost fills up, an XOFF should be emitted. When the buffer
  is no longer nearly full, send an XON. Otherwise, the network should neither
  generate nor eat XON or XOFF control characters.</p>

  <p>On Telenet, this can be met by setting CCIT X3 5:1 and 12:0 at both ends
  of the network. For best throughput, parameter 64 (advance ACK) should be set
  to something like 4. Packets should be forwarded when the packet is a full
  128 bytes, or after a moderate delay (3:0,4:10,6:0).</p>

  <p>With PC-Pursuit, it is sufficient to set parameter 5 to 1 at both ends
  after one is connected to the remote modem.</p>
  <pre>
        &lt;ENTER&gt;@&lt;ENTER&gt;
        set 5:1&lt;ENTER&gt;
        rst? 5:1&lt;ENTER&gt;
        cont&lt;ENTER&gt;
</pre>

  <p>Unfortunately, many PADs do not accept the &quot;rst?&quot; command.</p>

  <p>For YMODEM, PAD buffering should guarantee that a minimum of 1040
  characters can be sent in a burst without loss of data or generation of flow
  control characters. Failure to provide this buffering will generate excessive
  retries with YMODEM.</p>

  <table border="1" width="100%" cellspacing="0"
  summary="Network and Flow Control Compatibility">
    <caption>
      <a name="TABLE1" id="TABLE1">Table 1. Network and Flow Control
      Compatibility</a>
    </caption>

    <tr>
      <th>Connectivity</th>
      <th>Interactive</th>
      <th>XMODEM</th>
      <th>WXMODEM</th>
      <th>SUPERKERMIT</th>
      <th>ZMODEM</th>
    </tr>

    <tr>
      <td>Direct Connect</td>
      <td>YES</td>
      <td>YES</td>
      <td>YES</td>
      <td>YES</td>
      <td>YES</td>
    </tr>

    <tr>
      <td>Network, no FC</td>
      <td>no</td>
      <td>YES</td>
      <td><sup><a href="#ID*4">4</a></sup></td>
      <td><sup><a href="#ID*6">6</a></sup></td>
      <td>YES <sup><a href="#ID*1">1</a></sup></td>
    </tr>

    <tr>
      <td>Net, transparent FC</td>
      <td>YES</td>
      <td>YES</td>
      <td>YES</td>
      <td>YES</td>
      <td>YES</td>
    </tr>

    <tr>
      <td>Net, non-trans. FC</td>
      <td>YES</td>
      <td>no</td>
      <td>no <sup><a href="#ID*5">5</a></sup></td>
      <td>YES</td>
      <td>YES</td>
    </tr>

    <tr>
      <td>Network, 7 bit</td>
      <td>YES</td>
      <td>no</td>
      <td>no</td>
      <td>YES <sup><a href="#ID*2">2</a></sup></td>
      <td>YES <sup><a href="#ID*3">3</a></sup></td>
    </tr>
  </table>

  <ol>
    <li><a name="ID*1" id="ID*1">ZMODEM can optimize window size or burst
    length for fastest transfers.</a></li>
    <li><a name="ID*2" id="ID*2">Parity bits must be encoded, slowing binary
    transfers.</a></li>
    <li><a name="ID*3" id="ID*3">Natural protocol extension possible for
    encoding data to 7 bits.</a></li>
    <li><a name="ID*4" id="ID*4">Small WXMODEM window size may allow
    operation</a>.</li>
    <li><a name="ID*5" id="ID*5">Some flow control codes are not escaped in
    WXMODEM.</a></li>
    <li><a name="ID*6" id="ID*6">Kermit window size must be reduced to avoid
    buffer overrun.</a></li>
  </ol>

  <h2><a name="ID16_" id="ID16_">16. Performance Comparison Tables</a></h2>

  <p>&quot;Round Trip Delay Time&quot; includes the time for the last byte in a
  packet to propagate through the operating systems and network to the
  receiver, plus the time for the receiver&#39;s response to that packet to
  propagate back to the sender.</p>

  <p>The figures shown below are calculated for round trip delay times of 40
  milliseconds and 5 seconds. Shift registers in the two computers and a pair
  of 212 modems generate a round trip delay time on the order of 40
  milliseconds. Operation with busy timesharing computers and networks can
  easily generate round trip delays of five seconds. Because the round trip
  delays cause visible interruptions of data transfer when using XMODEM
  protocol, the subjective effect of these delays is greatly exaggerated,
  especially when the user is paying for connect time.</p>

  <p>A 102400 byte binary file with randomly distributed codes is sent at 1200
  bps 8 data bits, 1 stop bit. The calculations assume no transmission errors.
  For each of the protocols, only the per file functions are considered.
  Processor and I/O overhead are not included. YM-k refers to YMODEM with 1024
  byte data packets. YM-g refers to the YMODEM &quot;g&quot; option. ZMODEM
  uses 256 byte data subpackets for this example. SuperKermit uses maximum
  standard packet size, 8 bit transparent transmission, no run length
  compression. The 4 block WXMODEM window is too small to span the 5 second
  delay in this example; the resulting throughput degradation is ignored.</p>

  <p>For comparison, a straight &quot;dump&quot; of the file contents with no
  file management or error checking takes 853 seconds.</p>

  <table border="1" width="100%" cellspacing="0"
  summary="Protocol Overhead Information">
    <caption>
      <a name="TABLE2" id="TABLE2">Table 2. Protocol Overhead Information
      (102400 byte binary file, 5 Second Round Trip)</a>
    </caption>

    <tr>
      <th>Protocol</th>
      <th>XMODEM</th>
      <th>YM-k</th>
      <th>YM-g</th>
      <th>ZMODEM</th>
      <th>SKermit</th>
      <th>WXMODEM</th>
    </tr>

    <tr>
      <td>Protocol Round Trips</td>
      <td>804</td>
      <td>104</td>
      <td>5</td>
      <td>5</td>
      <td>5</td>
      <td>4</td>
    </tr>

    <tr>
      <td>Trip Time at 40ms</td>
      <td>32s</td>
      <td>4s</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>

    <tr>
      <td>Trip Time at 5s</td>
      <td>4020s</td>
      <td>520s</td>
      <td>25s</td>
      <td>25s</td>
      <td>25</td>
      <td>20</td>
    </tr>

    <tr>
      <td><b>Overhead Characters</b></td>
      <td>4803</td>
      <td>603</td>
      <td>503</td>
      <td>3600</td>
      <td>38280</td>
      <td>8000</td>
    </tr>

    <tr>
      <td><b>Line Turnarounds</b></td>
      <td>1602</td>
      <td>204</td>
      <td>5</td>
      <td>5</td>
      <td>2560</td>
      <td>1602</td>
    </tr>

    <tr>
      <td>Transfer Time at 0s</td>
      <td>893s</td>
      <td>858s</td>
      <td>857s</td>
      <td>883s</td>
      <td>1172s</td>
      <td>916s</td>
    </tr>

    <tr>
      <td>Transfer Time at 40ms</td>
      <td>925s</td>
      <td>862s</td>
      <td>857s</td>
      <td>883s</td>
      <td>1172s</td>
      <td>916s</td>
    </tr>

    <tr>
      <td>Transfer Time at 5s</td>
      <td>5766s</td>
      <td>1378s</td>
      <td>882s</td>
      <td>918s</td>
      <td>1197s</td>
      <td>936s</td>
    </tr>
  </table>

  <p><a name="Figure5" id="Figure5">Figure 5. Transmission Time Comparison
  (102400 byte binary file, 5 Second Round Trip)</a></p>
  <pre>
************************************************** XMODEM
************ YMODEM-K
********** SuperKermit (Sliding Windows)
******* ZMODEM 16kb Segmented Streaming
******* ZMODEM Full Streaming
******* YMODEM-G
</pre>

  <table border="1" width="100%" cellspacing="0"
  summary="Local Timesharing Computer Download Performance">
    <caption>
      <a name="TABLE3" id="TABLE3">Table 3. Local Timesharing Computer Download
      Performance</a>
    </caption>

    <tr>
      <th>Command</th>
      <th>Protocol</th>
      <th>Time/HD</th>
      <th>Time/FD</th>
      <th>Throughput</th>
      <th>Efficiency</th>
    </tr>

    <tr>
      <td>kermit -x</td>
      <td>Kermit</td>
      <td>1:49</td>
      <td>2:03</td>
      <td>327</td>
      <td>34%</td>
    </tr>

    <tr>
      <td>sz -Xa phones.t</td>
      <td>XMODEM</td>
      <td>1:20</td>
      <td>1:44</td>
      <td>343</td>
      <td>36%</td>
    </tr>

    <tr>
      <td>sz -a phones.t</td>
      <td>ZMODEM</td>
      <td>:39</td>
      <td>:48</td>
      <td>915</td>
      <td>95%</td>
    </tr>
  </table><br />
   Times were measured downloading a 35721 character text file at 9600 bps,
  from Santa Cruz SysV 2.1.2 Xenix on a 9 mHz IBM PC-AT to DOS 2.1 on an IBM
  PC. Xenix was in multiuser mode but otherwise idle. Transfer times to PC hard
  disk and floppy disk destinations are shown.

  <p>C-Kermit 4.2(030) used server mode and file compression, sending to
  Pro-YAM 15.52 using 0 delay and a &quot;get phones.t&quot; command.</p>

  <p>Crosstalk XVI 3.6 used XMODEM 8 bit checksum (CRC not available) and an
  &quot;ESC rx phones.t&quot; command. The Crosstalk time does not include the
  time needed to enter the extra commands not needed by Kermit and ZMODEM.</p>

  <p>Professional-YAM used ZMODEM AutoDownload. ZMODEM times included a
  security challenge to the sending program.</p>

  <table border="0" width="866" cellspacing="1"
  summary=" File Transfer Speeds">
    <caption>
      <a name="TABLE4" id="TABLE4">TABLE 4. File Transfer Speeds</a>
    </caption>

    <tr class="Highlight">
      <th width="79">Prot</th>
      <th width="161">file</th>
      <th width="96">bytes</th>
      <th width="68">bps</th>
      <th width="123">ch/sec</th>
      <th width="291">Notes</th>
    </tr>

    <tr>
      <td width="79">X</td>
      <td width="161">jancol.c</td>
      <td width="96">18237</td>
      <td width="68">2400</td>
      <td width="123">53</td>
      <td width="291">Tymnet PTL 5/3/87</td>
    </tr>

    <tr>
      <td width="79">X</td>
      <td width="161">source.xxx</td>
      <td width="96">6143</td>
      <td width="68">2400</td>
      <td width="123">56</td>
      <td width="291">Source PTL 5/29/87</td>
    </tr>

    <tr>
      <td width="79">X</td>
      <td width="161">jancol.c</td>
      <td width="96">18237</td>
      <td width="68">2400</td>
      <td width="123">64</td>
      <td width="291">Tymnet PTL</td>
    </tr>

    <tr>
      <td width="79">XN</td>
      <td width="161">tsrmaker.arc</td>
      <td width="96">25088</td>
      <td width="68">1200</td>
      <td width="123">94</td>
      <td width="291">GEnie PTL</td>
    </tr>

    <tr>
      <td width="79">B/ovth</td>
      <td width="161">emaibm.arc</td>
      <td width="96">51200</td>
      <td width="68">1200</td>
      <td width="123">101</td>
      <td width="291">CIS PTL MNP</td>
    </tr>

    <tr>
      <td width="79">UUCP</td>
      <td width="161">74 files,&nbsp; each</td>
      <td width="96">&gt;7000</td>
      <td width="68">1200</td>
      <td width="123">102</td>
      <td width="291">(Average)</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">jancol.c</td>
      <td width="96">18237</td>
      <td width="68">1200</td>
      <td width="123">112</td>
      <td width="291">DataPac (604-687-7144)</td>
    </tr>

    <tr>
      <td width="79">X/ovth</td>
      <td width="161">emaibm.arc</td>
      <td width="96">51200</td>
      <td width="68">1200</td>
      <td width="123">114</td>
      <td width="291">CIS PTL MNP</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">emaibm.arc</td>
      <td width="96">51200</td>
      <td width="68">1200</td>
      <td width="123">114</td>
      <td width="291">CIS PTL MNP</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">frombyte87.txt</td>
      <td width="96">62506</td>
      <td width="68">1200</td>
      <td width="123">117</td>
      <td width="291">BIX</td>
    </tr>

    <tr>
      <td width="79">SK</td>
      <td width="161">source.xxx</td>
      <td width="96">6143</td>
      <td width="68">2400</td>
      <td width="123">170</td>
      <td width="291">Source PTL 5/29/87</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">jancol.c</td>
      <td width="96">18237</td>
      <td width="68">2400</td>
      <td width="123">221</td>
      <td width="291">Tymnet PTL upl/dl</td>
    </tr>

    <tr>
      <td width="79">B/ovth</td>
      <td width="161">destro.gif</td>
      <td width="96">33613</td>
      <td width="68">2400</td>
      <td width="123">223</td>
      <td width="291">CIS/PTL 9-12-87</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">jancol.c</td>
      <td width="96">18237</td>
      <td width="68">2400</td>
      <td width="123">224</td>
      <td width="291">Tymnet PTL</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">tp40kerm.arc</td>
      <td width="96">112640</td>
      <td width="68">2400</td>
      <td width="123">224</td>
      <td width="291">BIX 6/88</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">readme.lis</td>
      <td width="96">9466</td>
      <td width="68">2400</td>
      <td width="123">231</td>
      <td width="291">BIX 6/88</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">jancol.c</td>
      <td width="96">18237</td>
      <td width="68">2400</td>
      <td width="123">226/218</td>
      <td width="291">TeleGodzilla upl</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">jancol.c</td>
      <td width="96">18237</td>
      <td width="68">2400</td>
      <td width="123">226</td>
      <td width="291">Tymnet PTL 5/3/87</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">zmodem.ov</td>
      <td width="96">35855</td>
      <td width="68">2400</td>
      <td width="123">227</td>
      <td width="291">CIS PTL node</td>
    </tr>

    <tr>
      <td width="79">C</td>
      <td width="161">jancol.c</td>
      <td width="96">18237</td>
      <td width="68">2400</td>
      <td width="123">229</td>
      <td width="291">Tymnet PTL 5/3/87</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">jancol.c</td>
      <td width="96">18237</td>
      <td width="68">2400&nbsp;</td>
      <td width="123">229/221</td>
      <td width="291">TeleGodzilla</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">zmodem.ov</td>
      <td width="96">35855</td>
      <td width="68">2400</td>
      <td width="123">229</td>
      <td width="291">CIS PTL node upl</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">jancol.c</td>
      <td width="96">18237</td>
      <td width="68">2400</td>
      <td width="123">232</td>
      <td width="291">CIS PTL node</td>
    </tr>

    <tr>
      <td width="79">QB</td>
      <td width="161">gifeof.arc</td>
      <td width="96">32187</td>
      <td width="68">2400</td>
      <td width="123">232</td>
      <td width="291">CIS PTL node</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">pcpbbs.txt</td>
      <td width="96">38423</td>
      <td width="68">2400</td>
      <td width="123">534</td>
      <td width="291">MNP Level 5</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">mbox</td>
      <td width="96">473104&nbsp;</td>
      <td width="68">9600</td>
      <td width="123">948/942</td>
      <td width="291">TeleGodzilla upl</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">zmodem.arc</td>
      <td width="96">318826&nbsp;</td>
      <td width="68">14k</td>
      <td width="123">1357/1345</td>
      <td width="291">TeleGodzilla</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">mbox</td>
      <td width="96">473104&nbsp;</td>
      <td width="68">14k</td>
      <td width="123">1367/1356</td>
      <td width="291">TeleGodzilla upl</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">c2.doc</td>
      <td width="96">218823</td>
      <td width="68">38k</td>
      <td width="123">3473</td>
      <td width="291">Xenix 386 TK upl</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">mbox -a</td>
      <td width="96">511893</td>
      <td width="68">38k</td>
      <td width="123">3860</td>
      <td width="291">386 Xenix 2.2 Beta</td>
    </tr>

    <tr>
      <td width="79">ZM</td>
      <td width="161">c.doc</td>
      <td width="96">218823</td>
      <td width="68">57k</td>
      <td width="123">5611</td>
      <td width="291">AT Clone &amp; 386</td>
    </tr>
  </table>

  <p>Times are for downloads unless noted. Where two speeds are noted, the
  faster speed is reported by the receiver because its transfer time
  calculation excludes the security check and transaction log file processing.
  The TeleGodzilla computer is a 4.77 mHz IBM PC with a 10 MB hard disk. The
  386 computer uses an Intel motherboard at 18 mHz 1ws. The AT Clone (QIC) runs
  at 8 mHz 0ws.</p>

  <dl>
    <dt>Abbreviations:</dt>
    <dt><b>B</b></dt>
    <dd>Compuserve B Protocol</dd>
    <dt><b>QB</b></dt>
    <dd>Compuserve Quick-B/B+ Protocol</dd>
    <dt><b>B/ovth</b></dt>
    <dd>CIS B with Omen Technology OverThruster&trade;</dd>
    <dt><b>C</b></dt>
    <dd>Capture DC2/DC4 (no protocol)</dd>
    <dt><b>K</b></dt>
    <dd>Kermit</dd>
    <dt><b>MNP</b></dt>
    <dd>Microcom MNP error correcting SX/1200 modem</dd>
    <dt><b>PTL</b></dt>
    <dd>Portland Oregon network node</dd>
    <dt><b>SK</b></dt>
    <dd>Sliding Window Kermit (SuperKermit) w=15</dd>
    <dt><b>X</b></dt>
    <dd>XMODEM</dd>
    <dt><b>XN</b></dt>
    <dd>XMODEM protocol implemented in network modes</dd>
    <dt><b>X/ovth</b></dt>
    <dd>XMODEM, Omen Technology OverThruster&trade;</dd>
    <dt><b>ZM</b></dt>
    <dd>ZMODEM</dd>
  </dl>

  <table border="1" width="100%" summary="Protocol Checklist">
    <caption>
      <a name="TABLE5" id="TABLE5">Table 5. Protocol Checklist Etc: Relay,
      BLAST, DART</a>
    </caption>

    <tr>
      <th width="14%" class="Highlight">Item</th>
      <th width="14%" class="Highlight">XMODEM</th>
      <th width="14%" class="Highlight">YMDM-k</th>
      <th width="14%" class="Highlight">YMDM-g</th>
      <th width="14%" class="Highlight">ZMODEM</th>
      <th width="15%" class="Highlight">SK</th>
      <th width="15%" class="Highlight">Etc.</th>
    </tr>

    <tr>
      <td width="14%">IN SERVICE</td>
      <td width="14%">1977</td>
      <td width="14%">1982</td>
      <td width="14%">1985</td>
      <td width="14%">1986</td>
      <td width="15%">1985</td>
      <td width="15%">?</td>
    </tr>

    <tr>
      <td width="14%">VENDORS</td>
      <td width="14%">?</td>
      <td width="14%">?</td>
      <td width="14%">&gt;20</td>
      <td width="14%">&gt;20</td>
      <td width="15%">?</td>
      <td width="15%">1</td>
    </tr>

    <tr>
      <td width="100%" class="Highlight" colspan="7">HOST AVAILABILITY</td>
    </tr>

    <tr>
      <td width="14%">Compuserve</td>
      <td width="14%">YES</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">YES</td>
      <td width="15%">&nbsp;</td>
      <td width="15%">&nbsp;</td>
    </tr>

    <tr>
      <td width="14%">BIX</td>
      <td width="14%">YES</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">YES</td>
      <td width="15%">YES</td>
      <td width="15%">&nbsp;</td>
    </tr>

    <tr>
      <td width="14%">Portal</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">YES</td>
      <td width="14%">&nbsp;</td>
      <td width="15%">&nbsp;</td>
      <td width="15%">SOON</td>
    </tr>

    <tr>
      <td width="14%">The Source</td>
      <td width="14%">YES</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="15%">YES</td>
      <td width="15%">&nbsp;</td>
    </tr>

    <tr>
      <td width="100%" colspan="7" class="Highlight">USER FEATURES</td>
    </tr>

    <tr>
      <td width="14%">User Friendly</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">YES</td>
      <td width="15%"><sup><a href="#IDn10">10</a></sup></td>
      <td width="15%">&nbsp;</td>
    </tr>

    <tr>
      <td width="14%">Commands/batch</td>
      <td width="14%">2*N</td>
      <td width="14%">2</td>
      <td width="14%">2</td>
      <td width="14%">1</td>
      <td width="15%">1<sup><a href="#IDn1">1</a></sup></td>
      <td width="15%">&nbsp;</td>
    </tr>

    <tr>
      <td width="14%">Commands/file</td>
      <td width="14%">2</td>
      <td width="14%">0</td>
      <td width="14%">0</td>
      <td width="14%">0</td>
      <td width="15%">0</td>
      <td width="15%">&nbsp;</td>
    </tr>

    <tr>
      <td width="14%">Command Download</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">YES</td>
      <td width="15%">YES<sup><a href="#IDn6">6</a></sup></td>
      <td width="15%">&nbsp;</td>
    </tr>

    <tr>
      <td width="14%">Menu Compatible</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">YES</td>
      <td width="15%">&nbsp;</td>
      <td width="15%">&nbsp;</td>
    </tr>

    <tr>
      <td width="14%">Crash Recovery</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">YES</td>
      <td width="15%">&nbsp;</td>
      <td width="15%">?</td>
    </tr>

    <tr>
      <td width="14%">File Management</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">YES</td>
      <td width="15%">&nbsp;</td>
      <td width="15%">some</td>
    </tr>

    <tr>
      <td width="14%">Security Check</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">YES</td>
      <td width="15%">&nbsp;</td>
      <td width="15%">&nbsp;</td>
    </tr>

    <tr>
      <td width="100%" colspan="7" class="Highlight">COMPATIBILITY</td>
    </tr>

    <tr>
      <td width="14%">Dynamic Files</td>
      <td width="14%">YES</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">YES</td>
      <td width="15%">YES</td>
      <td width="15%">?</td>
    </tr>

    <tr>
      <td width="14%">Packet SW NETS</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">YES</td>
      <td width="15%">YES</td>
      <td width="15%">?</td>
    </tr>

    <tr>
      <td width="14%">7 bit PS NETS</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%"><sup><a href="#IDn3">3</a></sup></td>
      <td width="15%">YES</td>
      <td width="15%">?</td>
    </tr>

    <tr>
      <td width="14%">Old Mainframes</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%">&nbsp;</td>
      <td width="14%"><sup><a href="#IDn3">3</a></sup></td>
      <td width="15%">YES</td>
      <td width="15%">?</td>
    </tr>

    <tr>
      <td width="100%" colspan="7" class="Highlight">ATTRIBUTES</td>
    </tr>

    <tr>
      <td width="14%">Reliability<sup><a href="#IDn5">5</a></sup></td>
      <td width="14%">fair</td>
      <td width="14%">fair<sup><a href="#IDn5">5</a></sup></td>
      <td width="14%">none</td>
      <td width="14%">BEST</td>
      <td width="15%">good</td>
      <td width="15%">?</td>
    </tr>

    <tr>
      <td width="14%">Streaming</td>
      <td width="14%">-</td>
      <td width="14%">-</td>
      <td width="14%">YES</td>
      <td width="14%">YES</td>
      <td width="15%">YES</td>
      <td width="15%">&nbsp;</td>
    </tr>

    <tr>
      <td width="14%">Overhead<sup><a href="#IDn2">2</a></sup></td>
      <td width="14%">7%</td>
      <td width="14%">1%</td>
      <td width="14%">1%</td>
      <td width="14%">4%<sup><a href="#IDn8">8</a></sup></td>
      <td width="15%">30%</td>
      <td width="15%">&nbsp;</td>
    </tr>

    <tr>
      <td width="14%">Faithful Xfers</td>
      <td width="14%">-</td>
      <td width="14%">YES<sup><a href="#IDn7">7</a></sup></td>
      <td width="14%">YES<sup><a href="#IDn7">7</a></sup></td>
      <td width="14%">YES</td>
      <td width="15%">YES</td>
      <td width="15%">?</td>
    </tr>

    <tr>
      <td width="14%">Preserve Date</td>
      <td width="14%">-</td>
      <td width="14%">YES</td>
      <td width="14%">YES</td>
      <td width="14%">YES</td>
      <td width="15%">-</td>
      <td width="15%">?</td>
    </tr>

    <tr>
      <td width="100%" colspan="7" class="Highlight">COMPLEXITY</td>
    </tr>

    <tr>
      <td width="14%">No-Wait Sample</td>
      <td width="14%">-</td>
      <td width="14%">-</td>
      <td width="14%">-</td>
      <td width="14%">opt</td>
      <td width="15%">REQD</td>
      <td width="15%">REQD</td>
    </tr>

    <tr>
      <td width="14%">Ring Buffers</td>
      <td width="14%">-</td>
      <td width="14%">-</td>
      <td width="14%">-</td>
      <td width="14%">opt</td>
      <td width="15%">REQD</td>
      <td width="15%">REQD</td>
    </tr>

    <tr>
      <td width="14%">Complexity</td>
      <td width="14%">LOW<sup><a href="#IDn5">5</a></sup></td>
      <td width="14%">LOW<sup><a href="#IDn5">5</a></sup></td>
      <td width="14%">LOW</td>
      <td width="14%">MED</td>
      <td width="15%">HIGH</td>
      <td width="15%">?</td>
    </tr>

    <tr>
      <td width="100%" colspan="7" class="Highlight">EXTENSIONS</td>
    </tr>

    <tr>
      <td width="14%">Server Operation</td>
      <td width="14%">-</td>
      <td width="14%">-</td>
      <td width="14%">-</td>
      <td width="14%">YES<sup><a href="#IDn4">4</a></sup></td>
      <td width="15%">YES</td>
      <td width="15%">?</td>
    </tr>

    <tr>
      <td width="14%">Multiple Threads</td>
      <td width="14%">-</td>
      <td width="14%">-</td>
      <td width="14%">-</td>
      <td width="14%">future</td>
      <td width="15%">-</td>
      <td width="15%">-</td>
    </tr>
  </table>

  <p>NOTES:</p>

  <ol>
    <li><a name="IDn1" id="IDn1">Server mode or Omen Technology Kermit
    AutoDownload</a></li>
    <li><a name="IDn2" id="IDn2">Character count, binary file, transparent
    channel</a></li>
    <li><a name="IDn3" id="IDn3">Future enhancement provided for</a></li>
    <li><a name="IDn4" id="IDn4">AutoDownload operation</a></li>
    <li><a name="IDn5" id="IDn5">Omen Technology&#39;s Cybernetic Data
    Recovery&trade; improves XMODEM and YMODEM reliability with complex
    proprietary logic.</a></li>
    <li><a name="IDn6" id="IDn6">Server commands only</a></li>
    <li><a name="IDn7" id="IDn7">Only with True YMODEM&trade;</a></li>
    <li><a name="IDn8" id="IDn8">More then 3% from protected network control
    characters</a></li>
    <li><a name="IDn9" id="IDn9">With Segmented Streaming</a></li>
    <li><a name="IDn10" id="IDn10">With Pro-YAM extensions</a></li>
  </ol>

  <h2><a name="ID17_" id="ID17_">17. Future Extensions</a></h2>

  <p>Future extensions include:</p>

  <ul>
    <li>Compatibility with 7 bit networks</li>
    <li>Server/Link Level operation: An END-TO-END error corrected program to
    program session is required for financial and other sensitive
    applications.</li>
    <li>Multiple independent threads</li>
    <li>Bidirectional transfers (STEREO ZMODEM)</li>
    <li>Encryption</li>
    <li>Compression</li>
    <li>File Comparison</li>
    <li>Selective transfer within a file (e.g., modified segments of a database
    file)</li>
    <li>Selective Retransmission for error correction</li>
  </ul>

  <h2><a name="ID18_Revisions" id="ID18_Revisions">18. Revisions</a></h2>

  <ul>
    <li>10-14-88 Pascal source code now available in Phil Burn&#39;s PibTerm
    v4.2. 6-24-88 An exception to the previously unconditional ZCBIN override:
    a ZCRESUM specified by the receiver need not be overridden by the
    sender&#39;s ZCBIN.</li>
    <li>11-18-87 Editorial improvements</li>
    <li>10-27-87 Optional fields added for number of files remaining to be sent
    and total number of bytes remaining to be sent.</li>
    <li>07-31-1987 The receiver should ignore a ZEOF with an offset that does
    not match the current file length. The previous action of responding with
    ZRPOS caused transfers to fail if a CRC error occurred immediately before
    end of file, because two retransmission requests were being sent for each
    error. This has been observed under exceptional conditions, such as data
    transmission at speeds greater than the receiving computer&#39;s interrupt
    response capability or gross misapplication of flow control.</li>
    <li>Discussion of the Tx backchannel garbage count and ZCRCW after error
    ZRPOS was added. Many revisions for clarity.</li>
    <li>07-09-87 Corrected XMODEM&#39;s development date, incorrectly stated as
    1979 instead of the actual August 1977. More performance data was
    added.</li>
    <li>05-30-87 Added ZMNEW and ZMSKNOLOC</li>
    <li>05-14-87 Window management, ZACK zshhdr XON removed, control character
    escaping, ZMSPARS changed to ZXPARS, editorial changes.</li>
    <li>04-13-87 The ZMODEM file transfer protocol&#39;s public domain status
    is emphasized.</li>
    <li>04-04-87: minor editorial changes, added conditionals for overview
    version.</li>
    <li>03-15-87: 32 bit CRC added.</li>
    <li>12-19-86: 0 Length ZCRCW data subpacket sent in response to ZPAD or
    ZDELE detected on reverse channel has been changed to ZCRCE. The reverse
    channel is now checked for activity before sending each ZDATA header.</li>
    <li>11-08-86: Minor changes for clarity.</li>
    <li>10-2-86: ZCNL definition expanded.</li>
    <li>9-11-86: ZMPROT file management option added.</li>
    <li>8-20-86: More performance data included.</li>
    <li>8-4-86: ASCII DLE (Ctrl-P, 020) now escaped; compatible with previous
    versions. More document revisions for clarity.</li>
    <li>7-15-86: This document was extensively edited to improve clarity and
    correct small errors. The definition of the ZMNEW management option was
    modified, and the ZMDIFF management option was added. The cancel sequence
    was changed from two to five CAN characters after spurious two character
    cancel sequences were detected.</li>
  </ul>

  <h2><a name="ID19_" id="ID19_">19. More Information</a></h2>

  <p>Please contact Omen Technology for troff source files and typeset copies
  of this document.</p>

  <h3><a name="ID19_1_" id="ID19_1_">19.1 TeleGodzilla Bulletin Board</a></h3>

  <p>More information may be obtained by calling the TeleGodzilla bulletin
  board at 503-621-3746. TeleGodzilla supports 19200 (Telebit PEP), 2400 and
  1200 bps callers with automatic speed recognition.</p>

  <p>Relevant files include YZMODEM.ZOO, YAMDEMO.ZOO, YAMHELP.ZOO,
  ZCOMMEXE.ARC, ZCOMMDOC.ARC, ZCOMMHLP.ARC.</p>

  <p>Useful commands for TeleGodzilla include &quot;menu&quot;,
  &quot;dir&quot;, &quot;sx file (XMODEM)&quot;, &quot;kermit sb file
  ...&quot;, and &quot;sz file ...&quot;.</p>

  <h3><a name="ID19_2_" id="ID19_2_">19.2 Unix UUCP Access</a></h3>

  <p>UUCP sites can obtain the current version of this file with uucp
  omen!/u/caf/public/zmodem.doc /tmp A continually updated list of available
  files is stored in /usr/spool/uucppublic/FILES. uucp omen!~uucp/FILES
  /usr/spool/uucppublic</p>

  <p>The following L.sys line allows UUCP to call site &quot;omen&quot; via
  Omen&#39;s bulletin board system &quot;TeleGodzilla&quot;. TeleGodzilla is an
  instance of Omen Technology&#39;s Professional-YAM in host operation, acting
  as a bulletin board and front ending a Xenix system.</p>

  <p>In response to TeleGodzilla&#39;s &quot;Name Please:&quot; (e:--e:),
  uucico gives the Pro-YAM &quot;link&quot; command as a user name.
  Telegodzilla then asks for a link password (d:). The password (Giznoid)
  controls access to the Xenix system connected to the IBM PC&#39;s other
  serial port. Communications between Pro-YAM and Xenix use 9600 bps; YAM
  converts this to the caller&#39;s speed.</p>

  <p>Finally, the calling uucico sees the Xenix &quot;Login:&quot; message
  (n:-- n:), and logs in as &quot;uucp&quot;. No password is used for the uucp
  account.</p>

  <p>omen Any ACU 2400 1-503-621-3746 e:--e: link d: Giznoid n:--n: uucp</p>

  <h2><a name="ID20_" id="ID20_">20. ZMODEM Programs</a></h2>

  <p>A copy of this document, a demonstration version of Professional-YAM, a
  flash-up tree structured help file and processor, are available in
  YZMODEM.ZOO on TeleGodzilla and other bulletin boards. This file must be
  unpacked with LOOZ.EXE, also available on TeleGodzilla. YZMODEM.ZOO may be
  distributed provided none of the files are deleted or modified without the
  written consent of Omen Technology.</p>

  <p>TeleGodzilla and other bulletin boards also feature ZCOMM, a shareware
  communications program. ZCOMM includes Omen Technology&#39;s
  TurboLearn&trade; Script Writer, ZMODEM, Omen&#39;s highly acclaimed XMODEM
  and YMODEM protocol support, Sliding Windows Kermit, several traditional
  protocols, a powerful script language, and the most accurate VT100/102
  emulation available in a usr supported program. The ZCOMM files include:</p>

  <ul>
    <li>ZCOMMEXE.ARC Executable files and beginner&#39;s telephone
    directory</li>
    <li>ZCOMMDOC.ARC &quot;Universal Line Printer Edition&quot; Manual</li>
    <li>ZCOMMHLP.ARC Tree structured Flash-UP help processor and database</li>
  </ul>

  <p>C source code and manual pages for the Unix/Xenix rz and sz programs are
  available on TeleGodzilla in RZSZ.ZOO. This ZOO archive may be unpacked with
  LOOZ.EXE, also available on TeleGodzilla. Most Unix like systems are
  supported, including V7, Sys III, 4.x BSD, SYS V, Idris, Coherent, and
  Regulus.</p>

  <p>RZSZ.ZOO includes a ZCOMM/Pro-YAM/PowerCom script ZUPL.T to upload the
  small (178 lines) YMODEM bootstrap program MINIRB.C without a file transfer
  protocol. MINIRB uses the Unix stty(1) program to set the required raw tty
  modes, and compiles without special flags on virtually all Unix and Xenix
  systems. ZUPL.T directs the Unix system to compile MINIRB, then uses it as a
  bootstrap to upload the rz/sz source and manual files.</p>

  <p>Pascal source code for ZMODEM support is available in PibTerm v4.2 written
  by Phil Burns.</p>

  <p>The PC-DOS EXEC-PC, QuickBBS, Opus and Nochange bulletin boards support
  ZMODEM. Integrated ZMODEM support for the Collie bulletin board program is
  planned. Most of the PC-DOS bulletin board programs that lack integrated
  ZMODEM support ZMODEM with external modules (DSZ, etc.).</p>

  <p>The BinkleyTerm, Dutchie and D&#39;Bridge email systems support ZMODEM as
  their primary protocol.</p>

  <p>The IN-SYNCH PC-DOS Teleconferencing system uses ZMODEM.</p>

  <p>The LAN modem sharing program Line Plus has announced ZMODEM support.</p>

  <p>Many programs have added direct ZMODEM support, including Crosstalk Mark
  IV, and Telix 3.</p>

  <p>Most other PC-DOS communications programs support external ZMODEM via Omen
  Technology&#39;s DSZ, including PibTerm, Qmodem SST and BOYAN.</p>

  <p>The ZMDM communications program by Jwahar Bammi runs on Atari ST
  machines.</p>

  <p>The Online! and A-Talk Gold programs for the Amiga support ZMODEM.</p>

  <p>The Byte Information eXchange supports ZMODEM. The Compuserve Information
  Service has ported the Unix rz/sz ZMODEM programs to DECSYSTEM 20 assembler,
  and has announced future support for ZMODEM.</p>

  <h3><a name="ID20_1_" id="ID20_1_">20.1 Adding ZMODEM to DOS
  Programs</a></h3>

  <p>DSZ is a small shareware program that supports XMODEM, YMODEM, and ZMODEM
  file transfers. DSZ is designed to be called from a bulletin board program or
  another communications program. It may be called as dsz port 2 sz file1 file2
  to send files, or as dsz port 2 rz to receive zero or more file(s), or as dsz
  port 2 rz filea fileb to receive two files, the first to filea and the second
  (if sent) to fileb. This form of dsz may be used to control the pathname of
  incoming file(s). In this example, if the sending program attempted to send a
  third file, the transfer would be terminated.</p>

  <p>Dsz uses DOS stdout for messages (no direct CRT access), acquires the COMM
  port vectors with standard DOS calls, and restores the COMM port&#39;s
  interrupt vector and registers upon exit.</p>

  <p>Further information on dsz may be found in dsz.doc and the ZCOMM or
  Pro-YAM user manuals.</p>

  <h2><a name="ID21_" id="ID21_">21. YMODEM Programs</a></h2>

  <p>The Unix rz/sz programs support YMODEM as well as ZMODEM. Most Unix like
  systems are supported, including V7, Sys III, 4.2 BSD, SYS V, Idris,
  Coherent, and Regulus.</p>

  <p>A version for VAX-VMS is available in VRBSB.SHQ, in the same
  directory.</p>

  <p>Irv Hoff has added 1k packets and YMODEM transfers to the KMD and IMP
  series programs, which replace the XMODEM and MODEM7/MDM7xx series
  respectively. Overlays are available for a wide variety of CP/M systems.</p>

  <p>Many other programs, including MEX-PLUS and Crosstalk Mark IV also support
  some of YMODEM&#39;s features.</p>

  <p>Questions about YMODEM, the Professional-YAM communications program, and
  requests for evaluation copies may be directed to:</p>

  <address>
    Chuck Forsberg<br />
    Omen Technology Inc<br />
    17505-V Sauvie Island Road<br />
    Portland Oregon 97231<br />
    VOICE: 503-621-3406 :VOICE<br />
    Modem (TeleGodzilla): 503-621-3746<br />
     Usenet: ...!tektronix!reed!omen!caf<br />
    Compuserve: 70007,2304<br />
    Source: TCE022
  </address>

  <h2><a name="ID22_" id="ID22_">22. Acknowledgments</a></h2>

  <p>The High Reliability Software&trade;, TurboLearn Script Writer&trade;,
  Cybernetic Data Recovery&trade;, AutoDownload&trade;, Intelligent Crash
  Recovery&trade;, Error Containment&trade;, Full Time Capture&trade;, True
  YMODEM&trade;, OverThruster&trade;, Password Guardian&trade;,
  CryptoScript&trade;, and TurboDial&trade; are Omen Technology trademarks.</p>

  <p>ZMODEM was developed for the public domain under a Telenet contract. The
  ZMODEM protocol descriptions and the Unix rz/sz program source code are
  public domain. No licensing, trademark, or copyright restrictions apply to
  the use of the protocol, the Unix rz/sz source code and the ZMODEM name.</p>

  <p>Encouragement and suggestions by Thomas Buck, Ward Christensen, Earl Hall,
  Irv Hoff, Stuart Mathison, and John Wales, are gratefully acknowledged. 32
  bit CRC code courtesy Gary S. Brown.</p>

  <h2><a name="ID23_" id="ID23_">23. Related Files</a></h2>

  <p>The following files may be useful while studying this document:</p>

  <p>YMODEM.DOC Describes the XMODEM, XMODEM-1k, and YMODEM batch file transfer
  protocols. This file is available on TeleGodzilla as YMODEM.DQC.</p>

  <p>zmodem.h Definitions for ZMODEM manifest constants</p>

  <p>rz.c, sz.c, rbsb.c Unix source code for operating ZMODEM programs.</p>

  <p>rz.1, sz.1 Manual pages for rz and sz (Troff sources).</p>

  <p>zm.c Operating system independent low level ZMODEM subroutines.</p>

  <p>minirb.c A YMODEM bootstrap program, 178 lines.</p>

  <p>RZSZ.ZOO,rzsz.arc Contain the C source code and manual pages listed above,
  plus a ZCOMM script to upload minirb.c to a Unix or Xenix system, compile it,
  and use the program to upload the ZMODEM source files with error
  checking.</p>

  <p>DSZ.ZOO,dsz.arc Contains DSZ.COM, a shareware X/Y/ZMODEM subprogram,
  DESQview &quot;pif&quot; files for background operation in minimum memory,
  and DSZ.DOC.</p>

  <p>ZCOMM*.ARC Archive files for ZCOMM, a powerful shareware communications
  program.</p>
  <hr />

  <ul>
    <li><a name="IDR1" class="Footnote" id="IDR1">1.</a> Some Kermit programs
    support run length encoding.</li>
    <li><a name="IDR2" class="Footnote" id="IDR2">2.</a> Unique to DSZ, ZCOMM,
    Professional-YAM and PowerCom</li>
    <li><a name="IDR3" class="Footnote" id="IDR3">3.</a> Provided the transmission
    medium accommodates X/YMODEM.</li>
    <li><a name="IDR4" class="Footnote" id="IDR4">4.</a> Except for the
    CAN-CAN-CAN-CAN-CAN abort sequence which requires five successive CAN
    characters.</li>
    <li><a name="IDR5" class="Footnote" id="IDR5">5.</a> Unique to Professional-YAM,
    ZCOMM, and PowerCom</li>
    <li><a name="IDR6" class="Footnote" id="IDR6">6.</a> Streaming strategies are
    discussed in coming chapters.</li>
    <li><a name="IDR7" class="Footnote" id="IDR7">7.</a> Without stopping for a
    response</li>
    <li><a name="IDR8" class="Footnote" id="IDR8">8.</a> The WINDOW is the data in
    transit between sender and receiver.</li>
    <li><a name="IDR9" class="Footnote" id="IDR9">9.</a> For example, when
    SuperKermit encounters certain errors, the wndesr function is called to
    determine the next block to request. A burst of errors generates several
    wasteful requests to retransmit the same block.</li>
    <li><a name="IDR10" class="Footnote" id="IDR10">10.</a> Available on
    TeleGodzilla as part of YZMODEM.ZOO</li>
    <li><a name="IDR11" class="Footnote" id="IDR11">11.</a> The ZMODEM design allows
    encoded packets for less transparent media.</li>
    <li><a name="IDR12" class="Footnote" id="IDR12">12.</a> With XOFF and XON, or
    out of band flow control such as X.25 or CTS</li>
    <li><a name="IDR13" class="Footnote" id="IDR13">13.</a> Files that have been
    translated in such a way as to modify their length cannot be updated with
    the ZCRECOV Conversion Option.</li>
    <li><a name="IDR14" class="Footnote" id="IDR14">14.</a> This and other constants
    are defined in the zmodem.h include file. Please note that constants with a
    leading 0 are octal constants in C.</li>
    <li><a name="IDR15" class="Footnote" id="IDR15">15.</a> The frame types are
    cardinal numbers beginning with 0 to minimize state transition table memory
    requirements.</li>
    <li><a name="IDR16" class="Footnote" id="IDR16">16.</a> Future extensions to
    ZMODEM may use the high order bits of the type byte to indicate thread
    selection.</li>
    <li><a name="IDR17" class="Footnote" id="IDR17">17.</a> Strategies for adjusting
    the subpacket length for optimal results based on real time error rates are
    still evolving. Shorter subpackets speed error detection but increase
    protocol overhead slightly.</li>
    <li><a name="IDR18" class="Footnote" id="IDR18">18.</a> Special considerations
    apply when sending commands.</li>
    <li><a name="IDR19" class="Footnote" id="IDR19">19.</a> If the receiver
    specifies the same or higher level of escaping, the ZSINIT frame need not
    be sent unless an Attn sequence is needed.</li>
    <li><a name="IDR20" class="Footnote" id="IDR20">20.</a> See below, under ZFILE
    header type.</li>
    <li><a name="IDR21" class="Footnote" id="IDR21">21.</a> The crc is initialized
    to 0xFFFFFFFF. A byte count of 0 implies the entire file.</li>
    <li><a name="IDR22" class="Footnote" id="IDR22">22.</a> This does not apply to
    files that have been translated.</li>
    <li><a name="IDR23" class="Footnote" id="IDR23">23.</a> If the ZMSPARS option is
    used, the receiver instead seeks to the position given in the ZDATA
    header.</li>
    <li><a name="IDR24" class="Footnote" id="IDR24">24.</a> The call to rdchk() in
    sz.c performs this function.</li>
    <li><a name="IDR25" class="Footnote" id="IDR25">25.</a> The obvious choice of
    ZCRCW packet, which would trigger an ZACK from the receiver, is not used
    because multiple in transit frames could result if the channel has a long
    propagation delay.</li>
    <li><a name="IDR26" class="Footnote" id="IDR26">26.</a> The call to getinsync()
    in sz.c performs this function.</li>
    <li><a name="IDR27" class="Footnote" id="IDR27">27.</a> If sampling is
    possible.</li>
    <li><a name="IDR28" class="Footnote" id="IDR28">28.</a> ZRPOS and other error
    packets are handled normally.</li>
    <li><a name="IDR29" class="Footnote" id="IDR29">29.</a> When used with modems or
    networks that simultaneously assert flow</li>
    <li><a name="IDR30" class="Footnote" id="IDR30">30.</a> One in 256 for escaping
    ZDLE, about two (four if 32 bit CRC is used) in 1024 for data subpacket
    CRC&#39;s</li>
    <li><a name="IDR31" class="Footnote" id="IDR31">31.</a> Filtering RUBOUT, NULL,
    Ctrl-Z, etc.</li>
    <li><a name="IDR32" class="Footnote" id="IDR32">32.</a> Or ZCOMPL in case of
    server mode.</li>
    <li><a name="IDR33" class="Footnote" id="IDR33">33.</a> Fields may not be
    skipped.</li>
  </ul>
  <!-- EOT ================================================================= -->
  <div id="ID_EOT" style="text-align: right">
    <hr />
    <a href="../index.html" title="Go to home&hellip;" class="Plain" target="_main">
    &#x2302;</a>
  </div>
  </body>
<!-- ==========================================================================
  $Log:
   8    Biblioteka1.7         2005-08-17 16:19:52  Darko Kolakovic xhtml
   7    Biblioteka1.6         2005-08-02 18:11:28  Darko Kolakovic Reformatting
   6    Biblioteka1.5         2005-07-29 16:06:30  Darko Kolakovic
   5    Biblioteka1.4         2005-07-28 10:25:52  Darko Kolakovic followed W3C
        recomendation
   4    Biblioteka1.3         2004-03-02 14:44:57  Darko           robots are
        allowed
   3    Biblioteka1.2         2003-01-27 11:25:34  Darko           Replaced CSS
   2    Biblioteka1.1         2002-11-07 08:39:29  Darko Kolakovic Added meta tags
   1    Biblioteka1.0         2002-10-07 17:03:01  Darko Kolakovic
  $
-->
</html>
